#include "Geometries.hh"
//Current standard geometry used for generating physics results, as well as past versions. Brief description of each version can be found at the beginning of its conditional.

//The following is a list of all geometry options currently implemented:
/*
  OriginalWithRock
  OriginalWithRangeCuts
  September2018WithCuts
  March2019WithCuts
  pCDR2019
  pCDR2020
  LNGS
*/
//You can also run a diagnostic by using the option 'Diagnostic'



if(GeometryOption == "OriginalWithRock")//Original rock definition
  {
    //Original geometry used for software testing in 2017
    //Rock is all one big shape, with holes cut out for lab and detector
    //In this example and many future examples, the detector assembly itself isn't defined, and there is no 'return' function. This is because the old detector assembly (including shielding components) is defined in DetectorConstruction.cc, and these options will loop back into that file and finish geometry definitions using this old assembly, if we let it. Therefore, for later geometries that define their own detector array, there is a return function.

    G4cout << G4endl <<  "OriginalWithRock: using rock at SURF, without range cuts..." << G4endl << G4endl;

    solid_Rock = new G4Box("sol_Rock",50*m,50*m,30*m);
    solid_Lab = new G4Box("sol_Lab",35*m,10*m,4*m);
    
    solid_Rock2 = new G4SubtractionSolid("sol_Rock2", solid_Rock, solid_Lab ,0 , G4ThreeVector(-25*m,0,10.5*m));
    solid_CutOut = new G4Tubs("sol_CutOut",0, 6.50001*m ,6.50001*m, 0, 2*M_PI);
    solid_Rock3 = new G4SubtractionSolid("sol_Rock3", solid_Rock2, solid_CutOut ,0 , G4ThreeVector(0,0,0));

    logical_Rock = new G4LogicalVolume(solid_Rock3,mat_Rock,"log_Rock");
    logical_Rock->SetVisAttributes ( new G4VisAttributes(G4Colour(0.7, 0.7, 0.7, 0.5) )); //grey 50% transparent
    physical_Rock = new G4PVPlacement(0,G4ThreeVector(),logical_Rock,"phy_Rock",logical_World,false,0,checkOverlaps);
  
  }//OriginalWithRock



 else if(GeometryOption=="OriginalWithRangeCuts")
   {
     //OriginalWithRangeCuts: in early 2018 I started using Geant4's so-called 'range cuts' to reduce the runtime of muon simulations significantly. These are currently de-optioned until such a time as large-scale statistical increases for simulations are deemed necessary. This is an example of the implementation of the range cuts. In the future, regions will be defined with a little more cohesion and a little less attention to detail...

     G4cout << G4endl << "OriginalWithRangeCuts: using rock at SURF with range cuts..." << G4endl << G4endl;

     solid_Rock = new G4Box("sol_Rock",50*m,50*m,30*m);
     solid_Lab = new G4Box("sol_Lab",35*m,10*m,4*m);

    
     //Separate the rock into two regions
     //The region closer to the detector will have better position res.

     inner_CutOut = new G4Tubs("inn_CutOut",0*m, 11.5*m, 11.5*m,0, 2*M_PI);

     outer_Rock = new G4SubtractionSolid("out_Rock", solid_Rock, solid_Lab ,0 , G4ThreeVector(-25*m,0,10.5*m));//cut out lab
    
     outer_Rock2 = new G4SubtractionSolid("out_Rock2", outer_Rock, inner_CutOut ,0 , G4ThreeVector(0,0,0));//cut out assembly and innerrock
    
     inner_Rock = new G4Tubs("inn_Rock",6.50001*m, 11.49999*m, 11.49999*m, 0, 2*M_PI); //assembly already cut out
    
     inner_Rock2 = new G4SubtractionSolid("inn_Rock2", inner_Rock, solid_Lab ,0 , G4ThreeVector(-25*m,0,10.5*m));//cut out lab
    
     logical_outerRock = new G4LogicalVolume(outer_Rock2,mat_Rock,"log_outRock");
    
     logical_outerRock->SetVisAttributes ( new G4VisAttributes(G4Colour(0.7, 0.7, 0.7, 0.5) )); //grey 50% transparent
    
     physical_outerRock = new G4PVPlacement(0,G4ThreeVector(),logical_outerRock,"phy_outerRock",logical_World,false,0,checkOverlaps);
    
     logical_innerRock = new G4LogicalVolume(inner_Rock2,mat_Rock,"log_innRock");
    
     logical_innerRock->SetVisAttributes ( new G4VisAttributes(G4Colour(0.7, 0.7, 0.7, 0.5) )); //grey 50% transparent
    
     physical_innerRock = new G4PVPlacement(0,G4ThreeVector(),logical_innerRock,"phy_innerRock",logical_World,false,0,checkOverlaps);
    
    
     //Define regions for custom range cuts in macro
     OuterRockRegion = new G4Region("OuterRockRegion");
     OuterRockRegion-> AddRootLogicalVolume(logical_outerRock);
     InnerRockRegion = new G4Region("InnerRockRegion");
     InnerRockRegion-> AddRootLogicalVolume(logical_innerRock);

   }//OriginalWithRangeCuts



 else if(GeometryOption == "September2018WithCuts")
   {
     //An iteration of the previous geometry, with some improvements made in order to remove excess rock material and make the simulations more efficient.

     G4cout << G4endl << "September2018WithCuts: using rock at SURF with range cuts and September2018 geometry..." << G4endl << G4endl;

     assemblyzoffset = -6.5*m;

     solid_Rock = new G4Box("sol_Rock",32.5*m,15*m,18*m);
     solid_Lab = new G4Box("sol_Lab",30*m,10*m,4*m);

     //Separate the rock into two regions
     //The region closer to the detector will have better position res.

     inner_CutOut = new G4Tubs("inn_CutOut",0*m, 11.5*m, 11.5*m,0, 2*M_PI);

     outer_Rock = new G4SubtractionSolid("out_Rock", solid_Rock, solid_Lab ,0 , G4ThreeVector(-2.5*m,0,4*m));//cut out lab
    
     outer_Rock2 = new G4SubtractionSolid("out_Rock2", outer_Rock, inner_CutOut ,0 , G4ThreeVector(17.5*m,0,-6.5*m));//cut out inner rock and assembly
    
     inner_Rock = new G4Tubs("inn_Rock",6.50001*m, 11.49999*m, 11.49999*m, 0, 2*M_PI); //assembly already cut out
    
     inner_Rock2 = new G4SubtractionSolid("inn_Rock2", inner_Rock, solid_Lab ,0 , G4ThreeVector(-20*m,0,10.5*m));//cut out lab
    
     logical_outerRock = new G4LogicalVolume(outer_Rock2,mat_Rock,"log_outRock");
    
     logical_outerRock->SetVisAttributes ( new G4VisAttributes(G4Colour(0.7, 0.7, 0.7, 0.5) )); //grey 50% transparent
    
     physical_outerRock = new G4PVPlacement(0,G4ThreeVector(-17.5*m,0,0),logical_outerRock,"phy_outerRock",logical_World,false,0,checkOverlaps);
    
     logical_innerRock = new G4LogicalVolume(inner_Rock2,mat_Rock,"log_innRock");
    
     logical_innerRock->SetVisAttributes ( new G4VisAttributes(G4Colour(0.7, 0.7, 0.7, 0.5) )); //grey 50% transparent
    
     physical_innerRock = new G4PVPlacement(0,G4ThreeVector(0,0,-6.5*m),logical_innerRock,"phy_innerRock",logical_World,false,0,checkOverlaps);
    
    
     //Define regions for custom range cuts in macro
     OuterRockRegion = new G4Region("OuterRockRegion");
     OuterRockRegion-> AddRootLogicalVolume(logical_outerRock);
     InnerRockRegion = new G4Region("InnerRockRegion");
     InnerRockRegion-> AddRootLogicalVolume(logical_innerRock);

   }//September2018WithCuts



 else if(GeometryOption == "March2019WithCuts")
   {
     //A final improvement of the previous geometry, with as much rock as allowable having been removed. This actually complicated the geometry in unnecessary ways, and this iteration was never actually implemented before the dramatic shift in geometry that occurs after this one.


     solid_Rock = new G4Box("sol_Rock",32.499999*m,15*m,9*m);
     solid_Lab = new G4Box("sol_Lab",30*m,10*m,4*m);
     assemblyzoffset = -4*m;

     //Separate the rock into two regions
     //The region closer to the detector will have better position res.

     inner_CutOut = new G4Tubs("inn_CutOut",0*m, 11.5*m, 11.5*m,0, 2*M_PI);

     outer_Rock = new G4SubtractionSolid("out_Rock", solid_Rock, solid_Lab ,0 , G4ThreeVector(-5*m,0,0));//cut out lab from top rock
    
     outer_Rock2 = new G4SubtractionSolid("out_Rock2", outer_Rock, inner_CutOut ,0 , G4ThreeVector(17.5*m,0,-10.5*m));//cut out inner rock and assembly
    
     inner_Rock = new G4Tubs("inn_Rock",6.50001*m, 11.49999*m, 11.49999*m, 0, 2*M_PI); //assembly already cut out
    
     inner_Rock2 = new G4SubtractionSolid("inn_Rock2", inner_Rock, solid_Lab ,0 , G4ThreeVector(-20*m,0,10.5*m));//cut out lab from inner rock
    
     logical_outerRock = new G4LogicalVolume(outer_Rock2,mat_Rock,"log_outRock");
    
     logical_outerRock->SetVisAttributes ( new G4VisAttributes(G4Colour(0.7, 0.7, 0.7, 0.5) )); //grey 50% transparent
    
     physical_outerRock = new G4PVPlacement(0,G4ThreeVector(-17.5*m,0,6.5*m),logical_outerRock,"phy_outerRock",logical_World,false,0,checkOverlaps);
    
     logical_innerRock = new G4LogicalVolume(inner_Rock2,mat_Rock,"log_innRock");
    
     logical_innerRock->SetVisAttributes ( new G4VisAttributes(G4Colour(0.7, 0.7, 0.7, 0.5) )); //grey 50% transparent
    
     physical_innerRock = new G4PVPlacement(0,G4ThreeVector(0,0,-4*m),logical_innerRock,"phy_innerRock",logical_World,false,0,checkOverlaps);
    
    
     //Define regions for custom range cuts in macro
     OuterRockRegion = new G4Region("OuterRockRegion");
     OuterRockRegion-> AddRootLogicalVolume(logical_outerRock);
     InnerRockRegion = new G4Region("InnerRockRegion");
     InnerRockRegion-> AddRootLogicalVolume(logical_innerRock);

   }//March2019WithCuts




 else if(GeometryOption=="pCDR2019")
   {
     //The first geometry implemented after the 2019 major overhaul. This geometry was made to reflect the LEGEND-1000 pre-Conceptual Design Report's early draft, to be presented to the Department of Energy later in 2020. This geometry was periodically updated to reflect changes in the pCDR specifications, but as more information was made available, it became apparent that the changes that needed to be made were too large to implement in the same version. Therefore, in January of 2020 this version was closed and a new version of the 'pCDR geometry' implemented For a discussion of the changes needed, see the next version.

     G4cout << "Outdated version of the geometry used in the pCDR. Saved for legacy purposes (this geometry was used for the results presented at the Dec 2019 LEGEND collaboration meeting, among other things)." << G4endl << G4endl;
     
     solid_Rock = new G4Box("sol_Rock",11*m,11*m,13*m);
     solid_Lab = new G4Box("sol_Lab",6*m,6*m,8*m);
     outer_Rock = new G4SubtractionSolid("out_Rock", solid_Rock, solid_Lab ,0 , G4ThreeVector(0,0,0));//cut out lab space from rock
     logical_outerRock = new G4LogicalVolume(outer_Rock,mat_Rock,"log_outRock");
     logical_outerRock->SetVisAttributes ( new G4VisAttributes(G4Colour(0.7, 0.7, 0.7, 0.5) )); //grey 50% transparent    
     physical_outerRock = new G4PVPlacement(0,G4ThreeVector(0,0,2*m),logical_outerRock,"phy_outerRock",logical_World,false,0,checkOverlaps);
     
     //Add general assembly of shielding
     
     waterShield = new G4Box("sol_Water",6*m,6*m,6*m);
     logical_waterShield = new G4LogicalVolume(waterShield,mat_Water,"log_waterShield");
     logical_waterShield->SetVisAttributes ( new G4VisAttributes(G4Colour(0.3, 0.6, 1.0,0.2) ));//blue hopefully
     physical_waterShield = new G4PVPlacement(0,G4ThreeVector(0,0,0),logical_waterShield,"phy_waterShield",logical_World,false,0,checkOverlaps);
     
     outerSSVessel = new G4Tubs("sol_outerSS",0*m, 3.6*m, 3.6*m, 0, 2*M_PI);
     
     logical_outerSSVessel = new G4LogicalVolume(outerSSVessel,mat_316Ti,"log_outerSSVessel");
     logical_outerSSVessel->SetVisAttributes ( new G4VisAttributes(G4Colour(0.5, 0.5, 0.5,0.9) ));//Grey
     physical_outerSSVessel = new G4PVPlacement(0,G4ThreeVector(0,0,0),logical_outerSSVessel,"phy_outerSSVessel",logical_waterShield,false,0,checkOverlaps);
     
     upperSSVessel = new G4Tubs("sol_upperSS",0*m, 1*m, 1.5*m, 0, 2*M_PI);
     logical_upperSSVessel = new G4LogicalVolume(upperSSVessel,mat_316Ti,"log_upperSSVessel");
     logical_upperSSVessel->SetVisAttributes ( new G4VisAttributes(G4Colour(0.5, 0.5, 0.5,0.9) ));//Grey
     physical_upperSSVessel = new G4PVPlacement(0,G4ThreeVector(0,0,5.02*m),logical_upperSSVessel,"phy_upperSSVessel",logical_waterShield,false,0,checkOverlaps);
     
     outerLArShield = new G4Tubs("sol_outerLArShield",0*m, 3.588*m, 3.588*m, 0, 2*M_PI);
     logical_outerLArShield = new G4LogicalVolume(outerLArShield,mat_ArLiq,"log_outerLArShield");
     logical_outerLArShield->SetVisAttributes ( new G4VisAttributes(G4Colour(0.1,0.9,0.1)) ); //green
     physical_outerLArShield = new G4PVPlacement(0,G4ThreeVector(0,0,0),logical_outerLArShield,"phy_outerLArShield",logical_outerSSVessel,false,0,checkOverlaps); 


     upperLArShield = new G4Tubs("sol_upperLArShield",0*m, 0.988*m, 1.488*m, 0, 2*M_PI);
     logical_upperLArShield = new G4LogicalVolume(upperLArShield,mat_ArLiq,"log_upperLArShield");
     logical_upperLArShield->SetVisAttributes ( new G4VisAttributes(G4Colour(0.1,0.9,0.1)) ); //green
     physical_upperLArShield = new G4PVPlacement(0,G4ThreeVector(0,0,0),logical_upperLArShield,"phy_upperLArShield",logical_upperSSVessel,false,0,checkOverlaps);
     
     //G4cout << "Mass of outer LAr shield before stuff is added: " << logical_outerLArShield->GetMass()/CLHEP::kg << G4endl;
     //G4cout << "Mass of upper LAr shield before stuff is added: " << logical_upperLArShield->GetMass()/CLHEP::kg << G4endl;
     //4 modules; each needs a unique logical volume, I guess... Otherwise name overlap issues occur
     
     
     innerCopperCryostat = new G4Tubs("sol_innerCu",0*m, 0.5*m, 1*m, 0, 2*M_PI);
     innerLArShield = new G4Tubs("sol_innerLArShield",0*m, 0.49*m, 0.99*m, 0, 2*M_PI);
          
     logical_innerCopperCryostat1 = new G4LogicalVolume(innerCopperCryostat,mat_Cu,"log_innerCopperCryostat1");
     logical_innerCopperCryostat1->SetVisAttributes ( new G4VisAttributes(G4Colour(0.62, 0.3, 0.2,0.7) ));//Brown
     physical_innerCopperCryostat = new G4PVPlacement(0,G4ThreeVector(1*m,0,0),logical_innerCopperCryostat1,"phy_innerCopperCryostat1",logical_outerLArShield,false,0,checkOverlaps);
     
     logical_innerCopperCryostat2 = new G4LogicalVolume(innerCopperCryostat,mat_Cu,"log_innerCopperCryostat2");
     logical_innerCopperCryostat2->SetVisAttributes ( new G4VisAttributes(G4Colour(0.62, 0.3, 0.2,0.7) ));//Brown
     physical_innerCopperCryostat = new G4PVPlacement(0,G4ThreeVector(-1*m,0,0),logical_innerCopperCryostat2,"phy_innerCopperCryostat2",logical_outerLArShield,false,0,checkOverlaps);
     
     logical_innerCopperCryostat3 = new G4LogicalVolume(innerCopperCryostat,mat_Cu,"log_innerCopperCryostat3");
     logical_innerCopperCryostat3->SetVisAttributes ( new G4VisAttributes(G4Colour(0.62, 0.3, 0.2,0.7) ));//Brown
     physical_innerCopperCryostat = new G4PVPlacement(0,G4ThreeVector(0,1*m,0),logical_innerCopperCryostat3,"phy_innerCopperCryostat3",logical_outerLArShield,false,0,checkOverlaps);
     
     logical_innerCopperCryostat4 = new G4LogicalVolume(innerCopperCryostat,mat_Cu,"log_innerCopperCryostat4");
     logical_innerCopperCryostat4->SetVisAttributes ( new G4VisAttributes(G4Colour(0.62, 0.3, 0.2,0.7) ));//Brown
     physical_innerCopperCryostat = new G4PVPlacement(0,G4ThreeVector(0,-1*m,0),logical_innerCopperCryostat4,"phy_innerCopperCryostat4",logical_outerLArShield,false,0,checkOverlaps);
     
     
     logical_innerLArShield1 = new G4LogicalVolume(innerLArShield,mat_ArLiq,"log_innerLArShield1");
     logical_innerLArShield1->SetVisAttributes ( new G4VisAttributes(G4Colour(0.1,0.9,0.1)) ); //green
     physical_innerLArShield = new G4PVPlacement(0,G4ThreeVector(0,0,0),logical_innerLArShield1,"phy_innerLArShield1",logical_innerCopperCryostat1,false,0,checkOverlaps);    
     
     logical_innerLArShield2 = new G4LogicalVolume(innerLArShield,mat_ArLiq,"log_innerLArShield2");
     logical_innerLArShield2->SetVisAttributes ( new G4VisAttributes(G4Colour(0.1,0.9,0.1)) ); //green
     physical_innerLArShield = new G4PVPlacement(0,G4ThreeVector(0,0,0),logical_innerLArShield2,"phy_innerLArShield2",logical_innerCopperCryostat2,false,0,checkOverlaps);    
     
     logical_innerLArShield3 = new G4LogicalVolume(innerLArShield,mat_ArLiq,"log_innerLArShield3");
     logical_innerLArShield3->SetVisAttributes ( new G4VisAttributes(G4Colour(0.1,0.9,0.1)) ); //green
     physical_innerLArShield = new G4PVPlacement(0,G4ThreeVector(0,0,0),logical_innerLArShield3,"phy_innerLArShield3",logical_innerCopperCryostat3,false,0,checkOverlaps);    
     
     logical_innerLArShield4 = new G4LogicalVolume(innerLArShield,mat_ArLiq,"log_innerLArShield4");
     logical_innerLArShield4->SetVisAttributes ( new G4VisAttributes(G4Colour(0.1,0.9,0.1)) ); //green
     physical_innerLArShield = new G4PVPlacement(0,G4ThreeVector(0,0,0),logical_innerLArShield4,"phy_innerLArShield4",logical_innerCopperCryostat4,false,0,checkOverlaps);    
     
     
     //detector array
     ICPCshell = new G4Tubs("sol_ICPCshell",0*m, 4.5*cm, 3.75*cm, 0, 2*M_PI);
     borehole = new G4Tubs("sol_borehole",0*m, 0.5*cm, 2.5*cm, 0, 2*M_PI);
     ICPCdetector = new G4SubtractionSolid("sol_ICPC", ICPCshell, borehole,0, G4ThreeVector(0,0,1.25*cm));//carve out borehole from ICPC
     logical_ICPCdetector  = new G4LogicalVolume(ICPCdetector,mat_Detector,"log_ICPC");
     logical_ICPCdetector->SetVisAttributes ( new G4VisAttributes(G4Colour(0.6,0.1,0.6)) );//Purple
     //G4cout << "Mass of a detector: " << logical_ICPCdetector->GetMass()/CLHEP::kg << G4endl;
     
     //physical_ICPCdetector  = new G4PVPlacement(0,G4ThreeVector(0,0,0),logical_ICPCdetector,"phy_ICPC",logical_innerLArShield1,false,0,checkOverlaps);    
     
     //There HAS to be a better way to implement the detector array than what I'm about to do. Gods of programming, please forgive me for this egregious crime against the holy principles of encapsulation and softcoding...
     
     const int numberofdetectors = 114;
     const int numberofstrings = 19;//1011 kg Ge76
     const int inscribingradius = 400;//mm
     const int verticalspacing = 250;//mm
     
     double azimuth = 0;
     int zcounter = 0;
     int longeststring = 0;
     
     double x = 0;
     double y = 0;
     double z = 0;
     
     longeststring = numberofdetectors/numberofstrings;
     if(numberofdetectors%numberofstrings)
       longeststring++;
     G4cout << longeststring << G4endl << G4endl;
     
     z = verticalspacing*(longeststring-1)/2;
     
     for (int i = 0; i < numberofdetectors; i++)
       {
	 
	 if(!(i%numberofstrings)&&(i))
	   z = z-verticalspacing;
	 
	 azimuth = (2*TMath::Pi()*(i%numberofstrings))/numberofstrings;
	 
	 x = TMath::Cos(azimuth)*inscribingradius;
	 y = TMath::Sin(azimuth)*inscribingradius;
	 
	 //G4cout << i << G4endl << "x: " << x << G4endl<< "y: " << y << G4endl << "z: " << z << G4endl << G4endl;
	 
	 detector_name = "phy_DetGeCrystal_";
	 detector_name += G4UIcommand::ConvertToString(i*4);
	 physical_ICPCdetector  = new G4PVPlacement(0,G4ThreeVector(x,y,z),logical_ICPCdetector,detector_name,logical_innerLArShield1,false,0,checkOverlaps);    
	 
	 detector_name = "phy_DetGeCrystal_";
	 detector_name += G4UIcommand::ConvertToString(i*4+1);
	 physical_ICPCdetector  = new G4PVPlacement(0,G4ThreeVector(x,y,z),logical_ICPCdetector,detector_name,logical_innerLArShield2,false,0,checkOverlaps);    
	 
	 detector_name = "phy_DetGeCrystal_";
	 detector_name += G4UIcommand::ConvertToString(i*4+2);
	 physical_ICPCdetector  = new G4PVPlacement(0,G4ThreeVector(x,y,z),logical_ICPCdetector,detector_name,logical_innerLArShield3,false,0,checkOverlaps);    
	 
	 detector_name = "phy_DetGeCrystal_";
	 detector_name += G4UIcommand::ConvertToString(i*4+3);
	 physical_ICPCdetector  = new G4PVPlacement(0,G4ThreeVector(x,y,z),logical_ICPCdetector,detector_name,logical_innerLArShield4,false,0,checkOverlaps);    
	 
       }
     
     //G4cout << "Mass after ICPC: " << logical_innerLArShield4->GetMass()/CLHEP::kg << G4endl;

     return physical_World;     
   
   }//pCDR2019



 else if(GeometryOption=="pCDR2020")
   {
     //The significant changes that necessitated a new geometry version were threefold. Firstly, the separation of the steel mass on top of the outer vessel into 4 entrant ports, which really should have just been done to begin with. Secondly, the extension of the inner copper cryostats and liquid argon, up through the chimneys. Thirdly, the implementation of the 'inner vessel' and subsequent implementation of vacuum where it should be (this volume used to be occupied by additional liquid argon). There are other, less significant changes, such as adjustments to the thickness of the outer steel vessel.

     G4cout << "Most up-to-date version of the 'pCDR' geometry is being used. Last updated January 30 2020." << G4endl << G4endl;
     
     solid_Rock = new G4Box("sol_Rock",11*m,11*m,13*m);
     solid_Lab = new G4Box("sol_Lab",6*m,6*m,8*m);
     outer_Rock = new G4SubtractionSolid("out_Rock", solid_Rock, solid_Lab ,0 , G4ThreeVector(0,0,0));//cut out lab space from rock
     logical_outerRock = new G4LogicalVolume(outer_Rock,mat_Rock,"log_outRock");
     logical_outerRock->SetVisAttributes ( new G4VisAttributes(G4Colour(0.7, 0.7, 0.7, 0.5) )); //grey 50% transparent    
     physical_outerRock = new G4PVPlacement(0,G4ThreeVector(0,0,2*m),logical_outerRock,"phy_outerRock",logical_World,false,0,checkOverlaps);
     
     //Add general assembly of shielding

     //water shield - 12m x 12m box     
     waterShield = new G4Box("sol_Water",6*m,6*m,6*m);
     logical_waterShield = new G4LogicalVolume(waterShield,mat_Water,"log_waterShield");
     logical_waterShield->SetVisAttributes ( new G4VisAttributes(G4Colour(0.3, 0.6, 1.0,0.2) ));//blue hopefully
     physical_waterShield = new G4PVPlacement(0,G4ThreeVector(0,0,0),logical_waterShield,"phy_waterShield",logical_World,false,0,checkOverlaps);

     //outer vessel - the space between this and the inner vessel is filled with vacuum
     //Implementing the thicker vessel specs in order to be conservative

     outerSSVessel = new G4Tubs("sol_outerSS",0*m, 3.6*m, 3.6*m, 0, 2*M_PI);
     logical_outerSSVessel = new G4LogicalVolume(outerSSVessel,mat_316Ti,"log_outerSSVessel");
     logical_outerSSVessel->SetVisAttributes ( new G4VisAttributes(G4Colour(0.5, 0.5, 0.5,0.9) ));//Grey
     physical_outerSSVessel = new G4PVPlacement(0,G4ThreeVector(0,0,0),logical_outerSSVessel,"phy_outerSSVessel",logical_waterShield,false,0,checkOverlaps);
     
     //The radius and height of this 'placement' determine the thickness of the outer vessel's walls
     //As per current design specs, the thickness of the side material is 25mm and the upper/lower material is 26mm
     vacuumSpace = new G4Tubs("sol_outerSS",0*m, 3.575*m, 3.574*m, 0, 2*M_PI);
     logical_vacuumSpace = new G4LogicalVolume(vacuumSpace,mat_vacuum,"log_vacuumSpace");
     logical_vacuumSpace->SetVisAttributes (G4VisAttributes::Invisible);//Invisible
     physical_vacuumSpace = new G4PVPlacement(0,G4ThreeVector(0,0,0),logical_vacuumSpace,"phy_vacuumSpace",logical_outerSSVessel,false,0,checkOverlaps);
     
     innerSSVessel = new G4Tubs("sol_innerSS",0*m, 3.5*m, 2*m, 0, 2*M_PI);
     logical_innerSSVessel = new G4LogicalVolume(innerSSVessel,mat_316Ti,"log_innerSSVessel");
     logical_innerSSVessel->SetVisAttributes ( new G4VisAttributes(G4Colour(0.5, 0.5, 0.5,0.9) ));//Grey
     physical_innerSSVessel = new G4PVPlacement(0,G4ThreeVector(0,0,1.5*m),logical_innerSSVessel,"phy_innerSSVessel",logical_vacuumSpace,false,0,checkOverlaps);

     SSChimney = new G4Tubs("sol_SSChimney",0.440*m,0.450*m,0.925*m,0,2*M_PI);
     logical_SSChimney = new G4LogicalVolume(SSChimney,mat_316Ti,"log_SSChimney");
     logical_SSChimney->SetVisAttributes ( new G4VisAttributes(G4Colour(0.5, 0.5, 0.5,0.9) ));//Grey
     physical_SSChimney = new G4PVPlacement(0,G4ThreeVector(1.*m,0.*m,4.525*m),logical_SSChimney,"phy_SSChimney",logical_waterShield,false,0,checkOverlaps);
     physical_SSChimney = new G4PVPlacement(0,G4ThreeVector(-1.*m,0.*m,4.525*m),logical_SSChimney,"phy_SSChimney",logical_waterShield,false,1,checkOverlaps);
     physical_SSChimney = new G4PVPlacement(0,G4ThreeVector(0.*m,-1.*m,4.525*m),logical_SSChimney,"phy_SSChimney",logical_waterShield,false,2,checkOverlaps);
     physical_SSChimney = new G4PVPlacement(0,G4ThreeVector(0.*m,1.*m,4.525*m),logical_SSChimney,"phy_SSChimney",logical_waterShield,false,3,checkOverlaps);

     //As per current design specs, the thickness of the side material is 15mm and the upper/lower material is 20mm
     outerLArShield = new G4Tubs("sol_outerLArShield",0*m, 3.485*m, 1.980*m, 0, 2*M_PI);
     logical_outerLArShield = new G4LogicalVolume(outerLArShield,mat_ArLiq,"log_outerLArShield");
     logical_outerLArShield->SetVisAttributes ( new G4VisAttributes(G4Colour(0.1,0.9,0.1)) ); //green
     physical_outerLArShield = new G4PVPlacement(0,G4ThreeVector(0,0,0),logical_outerLArShield,"phy_outerLArShield",logical_innerSSVessel,false,0,checkOverlaps); 

     //If desired, this is where the poly shield options should be implemented (search this file for keyword 'Bernhard' to know more)


     //4 modules; each needs a unique logical volume, I guess... Otherwise name overlap issues may occur. And, contrary to some peoples' beliefs, hitting the copypaste button isn't difficult.

     //pCDR information on these parts is sparse, so I had to improvise a lot...
         
     innerCopperCryostat = new G4Tubs("sol_innerCu",0*m, 0.44*m, 2.800*m, 0, 2*M_PI);
     innerLArShield = new G4Tubs("sol_innerLArShield",0*m, 0.43*m, 2.790*m, 0, 2*M_PI);
          
     logical_innerCopperCryostat1 = new G4LogicalVolume(innerCopperCryostat,mat_Cu,"log_innerCopperCryostat1");
     logical_innerCopperCryostat1->SetVisAttributes ( new G4VisAttributes(G4Colour(0.62, 0.3, 0.2,0.7) ));//Brown
     physical_innerCopperCryostat = new G4PVPlacement(0,G4ThreeVector(1*m,0,1.15*m),logical_innerCopperCryostat1,"phy_innerCopperCryostat1",logical_outerLArShield,false,0,checkOverlaps);
     
     logical_innerCopperCryostat2 = new G4LogicalVolume(innerCopperCryostat,mat_Cu,"log_innerCopperCryostat2");
     logical_innerCopperCryostat2->SetVisAttributes ( new G4VisAttributes(G4Colour(0.62, 0.3, 0.2,0.7) ));//Brown
     physical_innerCopperCryostat = new G4PVPlacement(0,G4ThreeVector(-1*m,0,1.15*m),logical_innerCopperCryostat2,"phy_innerCopperCryostat2",logical_outerLArShield,false,0,checkOverlaps);
     
     logical_innerCopperCryostat3 = new G4LogicalVolume(innerCopperCryostat,mat_Cu,"log_innerCopperCryostat3");
     logical_innerCopperCryostat3->SetVisAttributes ( new G4VisAttributes(G4Colour(0.62, 0.3, 0.2,0.7) ));//Brown
     physical_innerCopperCryostat = new G4PVPlacement(0,G4ThreeVector(0,1*m,1.15*m),logical_innerCopperCryostat3,"phy_innerCopperCryostat3",logical_outerLArShield,false,0,checkOverlaps);
     
     logical_innerCopperCryostat4 = new G4LogicalVolume(innerCopperCryostat,mat_Cu,"log_innerCopperCryostat4");
     logical_innerCopperCryostat4->SetVisAttributes ( new G4VisAttributes(G4Colour(0.62, 0.3, 0.2,0.7) ));//Brown
     physical_innerCopperCryostat = new G4PVPlacement(0,G4ThreeVector(0,-1*m,1.15*m),logical_innerCopperCryostat4,"phy_innerCopperCryostat4",logical_outerLArShield,false,0,checkOverlaps);
     
     
     logical_innerLArShield1 = new G4LogicalVolume(innerLArShield,mat_ArLiq,"log_innerLArShield1");
     logical_innerLArShield1->SetVisAttributes ( new G4VisAttributes(G4Colour(0.1,0.9,0.1)) ); //green
     physical_innerLArShield = new G4PVPlacement(0,G4ThreeVector(0,0,0),logical_innerLArShield1,"phy_innerLArShield1",logical_innerCopperCryostat1,false,0,checkOverlaps);    
     
     logical_innerLArShield2 = new G4LogicalVolume(innerLArShield,mat_ArLiq,"log_innerLArShield2");
     logical_innerLArShield2->SetVisAttributes ( new G4VisAttributes(G4Colour(0.1,0.9,0.1)) ); //green
     physical_innerLArShield = new G4PVPlacement(0,G4ThreeVector(0,0,0),logical_innerLArShield2,"phy_innerLArShield2",logical_innerCopperCryostat2,false,0,checkOverlaps);    
     
     logical_innerLArShield3 = new G4LogicalVolume(innerLArShield,mat_ArLiq,"log_innerLArShield3");
     logical_innerLArShield3->SetVisAttributes ( new G4VisAttributes(G4Colour(0.1,0.9,0.1)) ); //green
     physical_innerLArShield = new G4PVPlacement(0,G4ThreeVector(0,0,0),logical_innerLArShield3,"phy_innerLArShield3",logical_innerCopperCryostat3,false,0,checkOverlaps);    
     
     logical_innerLArShield4 = new G4LogicalVolume(innerLArShield,mat_ArLiq,"log_innerLArShield4");
     logical_innerLArShield4->SetVisAttributes ( new G4VisAttributes(G4Colour(0.1,0.9,0.1)) ); //green
     physical_innerLArShield = new G4PVPlacement(0,G4ThreeVector(0,0,0),logical_innerLArShield4,"phy_innerLArShield4",logical_innerCopperCryostat4,false,0,checkOverlaps);    


     //This is where the kill volume (search this file for keyword 'wrapper' if you want details) should be implemented if desired


     
     //detector array
     //pCDR information: 19 strings, 1000kg or so mass, 400mm inscribing radius (I used 375, which should be fine...)
     ICPCshell = new G4Tubs("sol_ICPCshell",0*m, 4.5*cm, 3.75*cm, 0, 2*M_PI);
     borehole = new G4Tubs("sol_borehole",0*m, 0.5*cm, 2.5*cm, 0, 2*M_PI);
     ICPCdetector = new G4SubtractionSolid("sol_ICPC", ICPCshell, borehole,0, G4ThreeVector(0,0,1.25*cm));//carve out borehole from ICPC
     logical_ICPCdetector  = new G4LogicalVolume(ICPCdetector,mat_Detector,"log_ICPC");
     logical_ICPCdetector->SetVisAttributes ( new G4VisAttributes(G4Colour(0.1,0.1,0.6)) );//~Artificial blue, Purple is 0.6 0.1 0.6

     //physical_ICPCdetector  = new G4PVPlacement(0,G4ThreeVector(0,0,0),logical_ICPCdetector,"phy_ICPC",logical_innerLArShield1,false,0,checkOverlaps);    
     
     //There HAS to be a better way to implement the detector array than what I'm about to do. Gods of programming, please forgive me for this egregious crime against the holy principles of encapsulation and softcoding...
     
     const int numberofdetectors = 114;
     const int numberofstrings = 19;//1011 kg Ge76
     const int inscribingradius = 375;//mm
     const int verticalspacing = 250;//mm
     
     double azimuth = 0;
     int zcounter = 0;
     int longeststring = 0;
     
     double x = 0;
     double y = 0;
     double z = 0;
     
     longeststring = numberofdetectors/numberofstrings;
     if(numberofdetectors%numberofstrings)
       longeststring++;
     //G4cout << longeststring << G4endl << G4endl;
     
     z = (verticalspacing*(longeststring-1)/2)-1850;//Number at the end is a flat displacement from the center of the new extended inner cylinders
          
     for (int i = 0; i < numberofdetectors; i++)
       {
	 
	 if(!(i%numberofstrings)&&(i))
	   z = z-verticalspacing;
	 
	 azimuth = (2*TMath::Pi()*(i%numberofstrings))/numberofstrings;
	 
	 x = TMath::Cos(azimuth)*inscribingradius;
	 y = TMath::Sin(azimuth)*inscribingradius;
	 
	 //G4cout << i << G4endl << "x: " << x << G4endl<< "y: " << y << G4endl << "z: " << z << G4endl << G4endl;
	 
	 detector_name = "phy_DetGeCrystal_";
	 detector_name += G4UIcommand::ConvertToString(i*4);
	 physical_ICPCdetector  = new G4PVPlacement(0,G4ThreeVector(x,y,z),logical_ICPCdetector,detector_name,logical_innerLArShield1,false,0,checkOverlaps);    
	 
	 detector_name = "phy_DetGeCrystal_";
	 detector_name += G4UIcommand::ConvertToString(i*4+1);
	 physical_ICPCdetector  = new G4PVPlacement(0,G4ThreeVector(x,y,z),logical_ICPCdetector,detector_name,logical_innerLArShield2,false,0,checkOverlaps);    
	 
	 detector_name = "phy_DetGeCrystal_";
	 detector_name += G4UIcommand::ConvertToString(i*4+2);
	 physical_ICPCdetector  = new G4PVPlacement(0,G4ThreeVector(x,y,z),logical_ICPCdetector,detector_name,logical_innerLArShield3,false,0,checkOverlaps);    
	 
	 detector_name = "phy_DetGeCrystal_";
	 detector_name += G4UIcommand::ConvertToString(i*4+3);
	 physical_ICPCdetector  = new G4PVPlacement(0,G4ThreeVector(x,y,z),logical_ICPCdetector,detector_name,logical_innerLArShield4,false,0,checkOverlaps);    
	 
       }
     
     return physical_World;     
     
   }//pCDR 2020


 else if(GeometryOption=="LNGS")
   {
     //Based (as much as it can be) on the design shown at Steve's Dec 2019 LEGEND meeting talk on alternative designs for LNGS
     //The idea is to use the L200 vessel for 1/4 of the detectors, then build one huge water tank next to it to house 3 very similar
     //newly-built vessels. I assume the material is going to be 316Ti, much as it is for the L200 vessel, with a copper lining in the middle part.

     G4cout <<"Geometry is LNGS-specific baseline design, implemented April 2020" << G4endl << G4endl;

     //Define the overall lab space. Looks like 1500cm along y, 4400 cm along x, 1000 cm along z will suffice
     //Can't forget the 3m of rock on all sides... Man, muons are gonna take a long time in here!
     //The roof is arched, so put another semicircle of 500cm radius on top for extra lab space


     LNGSrock = new G4Box("sol_LNGSrock",2500*cm,1050*cm,1175*cm);
     LNGSlabLower = new G4Box("sol_LNGSlabLower",2200*cm,750*cm,500*cm);
     LNGSlabUpper = new G4Tubs("sol_LNGSlabUpper",0, 750*cm, 2200*cm, 0, 1*M_PI);
     logical_LNGSrock  = new G4LogicalVolume(LNGSrock,mat_Rock,"log_LNGSrock");
     logical_LNGSrock->SetVisAttributes ( new G4VisAttributes(G4Colour(0.5,0.5,0.5,0.75)) );//Gray, mostly transparent
     physical_LNGSrock  = new G4PVPlacement(0,G4ThreeVector(0,0,0),logical_LNGSrock,"phy_LNGSrock",logical_World,false,0,checkOverlaps);  
     logical_LNGSlabLower  = new G4LogicalVolume(LNGSlabLower,mat_air,"log_LNGSlabLower");
     logical_LNGSlabLower->SetVisAttributes ( new G4VisAttributes(G4Colour(0.5,0.5,0.5,0.75)) );//Gray, mostly transparent
     physical_LNGSlabLower  = new G4PVPlacement(0,G4ThreeVector(0,0,-375*cm),logical_LNGSlabLower,"phy_LNGSlabLower",logical_LNGSrock,false,0,checkOverlaps);
     logical_LNGSlabUpper  = new G4LogicalVolume(LNGSlabUpper,mat_air,"log_LNGSlabUpper");
     logical_LNGSlabUpper->SetVisAttributes ( new G4VisAttributes(G4Colour(0.5,0.5,0.5,0.75)) );//Gray, mostly transparent
     rotm  = new G4RotationMatrix();
     rotm->rotateX(90*deg); 
     rotm->rotateY(90*deg);
      rotm->rotateX(180*deg); 
     physical_LNGSlabUpper  = new G4PVPlacement(rotm,G4ThreeVector(0,0,125*cm),logical_LNGSlabUpper,"phy_LNGSlabUpper",logical_LNGSrock,false,0,checkOverlaps);

     //Next, the water tanks
     //One will have L200 dimensions (1000cm cylinder) and one will be a new rectangular prism (2000cmx1000cmx1000cm)
     //Rectangular tank is 1664cm (we'll call it 1650) from the "left" wall (when viewed along the y axis)
     //L200 tank is more or less right against it, minus a set of stairs (we'll say 1m displacement)
     //Half-x of lab space is 2200 cm, so L200 tank's leftmost point is at -2100cm, e.g. its center is at -1600 cm x
     //Rectangular tank's leftmost point is then at -550cm from center of lab space, meaning centered at +450cm
     //Detectors are displaced in y too? Sheesh man
     //Both sets have their centers ~950 cm from the "back" wall, when viewing along the y axis
     //L200 tank's backmost point is +50 cm, so its center is -200 cm in y
     //Rectangular tank is as wide in y, so same case
     //No z information given so I'll go out on a limb and assume the detectors are sitting on the floor... Which is at -500cm from z origin
     //So tanks can be at 0 in z no problemo

LNGSsmallWaterShield =  new G4Tubs("sol_LNGSsmallWaterShield",0, 500*cm, 500*cm, 0, 2*M_PI);
//Nobody cares about the water tank's vessel... Like, it's not even pictured in GERDA's officially published figures!
 logical_LNGSsmallWaterShield = new G4LogicalVolume(LNGSsmallWaterShield,mat_Water,"log_LNGSsmallWaterShield");
 logical_LNGSsmallWaterShield->SetVisAttributes( new G4VisAttributes(G4Colour(0.3, 0.6, 1.0,0.2) ));//blue
 physical_LNGSsmallWaterShield = new G4PVPlacement(0,G4ThreeVector(-1600*cm,200*cm,0),logical_LNGSsmallWaterShield,"phy_LNGSsmallWaterShield",logical_LNGSlabLower,false,0,checkOverlaps);
LNGSlargeWaterShield =  new G4Box("sol_LNGSlargeWaterShield",1000*cm, 500*cm, 500*cm);

 logical_LNGSlargeWaterShield = new G4LogicalVolume(LNGSlargeWaterShield,mat_Water,"log_LNGSlargeWaterShield");
 logical_LNGSlargeWaterShield->SetVisAttributes( new G4VisAttributes(G4Colour(0.3, 0.6, 1.0,0.2) ));//blue
 physical_LNGSlargeWaterShield = new G4PVPlacement(0,G4ThreeVector(450*cm,200*cm,0),logical_LNGSlargeWaterShield,"phy_LNGSlargeWaterShield",logical_LNGSlabLower,false,0,checkOverlaps);

 //Next, the stainless steel vessels
 //I'll assume that they're radius 200 cm each, like in L200
 //Thickness... lord knows, nobody posted them on Github, so I'll hazard a guess at, man I dunno, 1 cm?
 //I'll put 1 cm copper plating on the inside later, as well
 //The neck is radius 40 cm, by the way

     LNGSsteelVessel = new G4Tubs("sol_LNGSsteelVessel",0*m, 2*m, 2*m,0, 2*M_PI);
 logical_LNGSsteelVessel = new G4LogicalVolume(LNGSsteelVessel,mat_316Ti,"log_LNGSsteelVessel");
 logical_LNGSsteelVessel->SetVisAttributes( new G4VisAttributes(G4Colour(0.85, 0.85, 0.85,0.5) ));//light gray
 physical_LNGSsteelVessel = new G4PVPlacement(0,G4ThreeVector(0,0,0),logical_LNGSsteelVessel,"phy_LNGSsteelVessel1",logical_LNGSsmallWaterShield,false,0,checkOverlaps);
 //Need to place copies in the large water tank too, 5m apart each as well as 5m from the x-edges of the tank
physical_LNGSsteelVessel = new G4PVPlacement(0,G4ThreeVector(-500*cm,0,0),logical_LNGSsteelVessel,"phy_LNGSsteelVessel2",logical_LNGSlargeWaterShield,false,1,checkOverlaps);
physical_LNGSsteelVessel = new G4PVPlacement(0,G4ThreeVector(0,0,0),logical_LNGSsteelVessel,"phy_LNGSsteelVessel3",logical_LNGSlargeWaterShield,false,2,checkOverlaps);
physical_LNGSsteelVessel = new G4PVPlacement(0,G4ThreeVector(500*cm,0,0),logical_LNGSsteelVessel,"phy_LNGSsteelVessel4",logical_LNGSlargeWaterShield,false,3,checkOverlaps);
 LNGSargonShield = new G4Tubs("sol_LNGSargonShield",0*m, 1.99*m, 1.99*m,0, 2*M_PI);
 logical_LNGSargonShield = new G4LogicalVolume(LNGSargonShield,mat_ArLiq,"log_LNGSargonShield");
 logical_LNGSargonShield->SetVisAttributes( new G4VisAttributes(G4Colour(0.2, 0.9, 0.2,0.2) ));//green
 physical_LNGSargonShield = new G4PVPlacement(0,G4ThreeVector(0,0,0),logical_LNGSargonShield,"phy_LNGSargonShield",logical_LNGSsteelVessel,false,0,checkOverlaps);
 // physical_LNGSargonShield = new G4PVPlacement(0,G4ThreeVector(0,0,0),logical_LNGSargonShield,"phy_LNGSargonShield2",logical_LNGSsteelVessel,false,1,checkOverlaps);
 // physical_LNGSargonShield = new G4PVPlacement(0,G4ThreeVector(0,0,0),logical_LNGSargonShield,"phy_LNGSargonShield3",logical_LNGSsteelVessel,false,2,checkOverlaps);
 // physical_LNGSargonShield = new G4PVPlacement(0,G4ThreeVector(0,0,0),logical_LNGSargonShield,"phy_LNGSargonShield4",logical_LNGSsteelVessel,false,3,checkOverlaps);

 //Copper cladding can go inside the liquid argon. What's the height on these things? I guess I'll say 2.5m
 //Not implemented as of 6/9/2020 nice
 /*     LNGScopperCladding = new G4Tubs("sol_LNGScopperCladding",198*cm, 199*cm, 125*cm,0, 2*M_PI);
 logical_LNGScopperCladding = new G4LogicalVolume(LNGScopperCladding,mat_Cu,"log_LNGScopperCladding");
 logical_LNGScopperCladding->SetVisAttributes( new G4VisAttributes(G4Colour(0.62, 0.3, 0.2,0.7) ));//Brown
 physical_LNGScopperCladding = new G4PVPlacement(0,G4ThreeVector(0,0,0),logical_LNGScopperCladding,"phy_LNGScopperCladding1",logical_LNGSargonShield,false,0,checkOverlaps);
 physical_LNGScopperCladding = new G4PVPlacement(0,G4ThreeVector(0,0,0),logical_LNGScopperCladding,"phy_LNGScopperCladding1",logical_LNGSargonShield,false,1,checkOverlaps);
 physical_LNGScopperCladding = new G4PVPlacement(0,G4ThreeVector(0,0,0),logical_LNGScopperCladding,"phy_LNGScopperCladding1",logical_LNGSargonShield,false,2,checkOverlaps);
 physical_LNGScopperCladding = new G4PVPlacement(0,G4ThreeVector(0,0,0),logical_LNGScopperCladding,"phy_LNGScopperCladding1",logical_LNGSargonShield,false,3,checkOverlaps);*/


     LNGSsteelNeck = new G4Tubs("sol_LNGSsteelNeck",0*m, 40*cm, 80*cm,0, 2*M_PI);
 logical_LNGSsteelNeck = new G4LogicalVolume(LNGSsteelNeck,mat_316Ti,"log_LNGSsteelNeck");
 logical_LNGSsteelNeck->SetVisAttributes( new G4VisAttributes(G4Colour(0.85, 0.85, 0.85,0.5) ));//light gray
 physical_LNGSsteelNeck = new G4PVPlacement(0,G4ThreeVector(0,0,280*cm),logical_LNGSsteelNeck,"phy_LNGSsteelNeck1",logical_LNGSsmallWaterShield,false,0,checkOverlaps);
 //Need to place copies in the large water tank too, 5m apart each as well as 5m from the x-edges of the tank
physical_LNGSsteelNeck = new G4PVPlacement(0,G4ThreeVector(-500*cm,0,280*cm),logical_LNGSsteelNeck,"phy_LNGSsteelNeck2",logical_LNGSlargeWaterShield,false,1,checkOverlaps);
physical_LNGSsteelNeck = new G4PVPlacement(0,G4ThreeVector(0,0,280*cm),logical_LNGSsteelNeck,"phy_LNGSsteelNeck3",logical_LNGSlargeWaterShield,false,2,checkOverlaps);
physical_LNGSsteelNeck = new G4PVPlacement(0,G4ThreeVector(500*cm,0,280*cm),logical_LNGSsteelNeck,"phy_LNGSsteelNeck4",logical_LNGSlargeWaterShield,false,3,checkOverlaps);
  LNGSargonNeck = new G4Tubs("sol_LNGSargonNeck",0*m, 39*cm, 80*cm,0, 2*M_PI);
 logical_LNGSargonNeck = new G4LogicalVolume(LNGSargonNeck,mat_ArLiq,"log_LNGSargonNeck");
 logical_LNGSargonNeck->SetVisAttributes( new G4VisAttributes(G4Colour(0.2, 0.9, 0.2,0.5) ));//green
 physical_LNGSargonNeck = new G4PVPlacement(0,G4ThreeVector(0,0,0),logical_LNGSargonNeck,"phy_LNGSargonNeck1",logical_LNGSsteelNeck,false,0,checkOverlaps);
 //physical_LNGSargonNeck = new G4PVPlacement(0,G4ThreeVector(0,0,0),logical_LNGSargonNeck,"phy_LNGSargonNeck2",logical_LNGSsteelNeck,false,1,checkOverlaps);
 //physical_LNGSargonNeck = new G4PVPlacement(0,G4ThreeVector(0,0,0),logical_LNGSargonNeck,"phy_LNGSargonNeck3",logical_LNGSsteelNeck,false,2,checkOverlaps);
 //physical_LNGSargonNeck = new G4PVPlacement(0,G4ThreeVector(0,0,0),logical_LNGSargonNeck,"phy_LNGSargonNeck4",logical_LNGSsteelNeck,false,3,checkOverlaps);

 //Finally, it's time to implement the detector array
 //For now, just use the array in the other geometry, change placement

     ICPCshell = new G4Tubs("sol_ICPCshell",0*m, 4.5*cm, 3.75*cm, 0, 2*M_PI);
     borehole = new G4Tubs("sol_borehole",0*m, 0.5*cm, 2.5*cm, 0, 2*M_PI);
     ICPCdetector = new G4SubtractionSolid("sol_ICPC", ICPCshell, borehole,0, G4ThreeVector(0,0,1.25*cm));//carve out borehole from ICPC
     logical_ICPCdetector  = new G4LogicalVolume(ICPCdetector,mat_Detector,"log_ICPC");
     logical_ICPCdetector->SetVisAttributes ( new G4VisAttributes(G4Colour(0.6,0.1,0.6)) );//Purple
     
     const int numberofdetectors = 114;
     const int numberofstrings = 19;//1011 kg Ge76
     const int inscribingradius = 375;//mm
     const int verticalspacing = 250;//mm
     
     double azimuth = 0;
     int zcounter = 0;
     int longeststring = 0;
     
     double x = 0;
     double y = 0;
     double z = 0;
     
     longeststring = numberofdetectors/numberofstrings;
     if(numberofdetectors%numberofstrings)
       longeststring++;
     //G4cout << longeststring << G4endl << G4endl;
     
     z = (verticalspacing*(longeststring-1)/2);//Number at the end is a flat displacement 
     
     for (int i = 0; i < numberofdetectors; i++)
       {
	 
	 if(!(i%numberofstrings)&&(i))
	   z = z-verticalspacing;
	 
	 azimuth = (2*TMath::Pi()*(i%numberofstrings))/numberofstrings;
	 
	 x = TMath::Cos(azimuth)*inscribingradius;
	 y = TMath::Sin(azimuth)*inscribingradius;
	 
	 //G4cout << i << G4endl << "x: " << x << G4endl<< "y: " << y << G4endl << "z: " << z << G4endl << G4endl;
	 
	 detector_name = "phy_DetGeCrystal_";
	 detector_name += G4UIcommand::ConvertToString(i);
	 physical_ICPCdetector  = new G4PVPlacement(0,G4ThreeVector(x,y,z),logical_ICPCdetector,detector_name,logical_LNGSargonShield,false,0,checkOverlaps);    
	 
	 /*detector_name = "phy_DetGeCrystal_";
	 detector_name += G4UIcommand::ConvertToString(i*4+1);
	 physical_ICPCdetector  = new G4PVPlacement(0,G4ThreeVector(x,y,z),logical_ICPCdetector,detector_name,logical_LNGSargonShield,false,1,checkOverlaps);    
	 
	 detector_name = "phy_DetGeCrystal_";
	 detector_name += G4UIcommand::ConvertToString(i*4+2);
	 physical_ICPCdetector  = new G4PVPlacement(0,G4ThreeVector(x,y,z),logical_ICPCdetector,detector_name,logical_LNGSargonShield,false,2,checkOverlaps);    
	 
	 detector_name = "phy_DetGeCrystal_";
	 detector_name += G4UIcommand::ConvertToString(i*4+3);
	 physical_ICPCdetector  = new G4PVPlacement(0,G4ThreeVector(x,y,z),logical_ICPCdetector,detector_name,logical_LNGSargonShield,false,3,checkOverlaps);    
	 */
       }



     return physical_World;

   }//LNGS



 else if(GeometryOption=="Diagnostic")
   {
     //Make a diagnostic geometry, with every component spatially separated and weighed
     //This will involve a lot of subtraction solids... Should probably work from the inside out, from oldest to newest geometry option
     
     G4cout << G4endl << G4endl << "Diagnostic option selected. Printing all shape names and masses for pCDR-like geometries..." << G4endl << G4endl;
     G4cout << "All masses given in kg" << G4endl << G4endl;
     G4cout <<"pCDR2019 diagnostics:" << G4endl << G4endl << G4endl;
     
     //detector array
     //pCDR information: 19 strings, 1000kg or so mass, 400mm inscribing radius (I used 375, which should be fine...)
     ICPCshell = new G4Tubs("sol_ICPCshell",0*m, 4.5*cm, 3.75*cm, 0, 2*M_PI);
     borehole = new G4Tubs("sol_borehole",0*m, 0.5*cm, 2.5*cm, 0, 2*M_PI);
     ICPCdetector = new G4SubtractionSolid("sol_ICPC", ICPCshell, borehole,0, G4ThreeVector(0,0,1.25*cm));//carve out borehole from ICPC
     logical_ICPCdetector  = new G4LogicalVolume(ICPCdetector,mat_Detector,"log_ICPC");
     logical_ICPCdetector->SetVisAttributes ( new G4VisAttributes(G4Colour(0.6,0.1,0.6)) );//Purple
     
     const int numberofdetectors = 114;
     const int numberofstrings = 19;//1011 kg Ge76
     const int inscribingradius = 375;//mm
     const int verticalspacing = 250;//mm
     
     double azimuth = 0;
     int zcounter = 0;
     int longeststring = 0;
     
     double x = 0;
     double y = 0;
     double z = 0;
     
     longeststring = numberofdetectors/numberofstrings;
     if(numberofdetectors%numberofstrings)
       longeststring++;
     //G4cout << longeststring << G4endl << G4endl;
     
     z = (verticalspacing*(longeststring-1)/2)+15500;//Number at the end is a flat displacement 
     
     for (int i = 0; i < numberofdetectors; i++)
       {
	 
	 if(!(i%numberofstrings)&&(i))
	   z = z-verticalspacing;
	 
	 azimuth = (2*TMath::Pi()*(i%numberofstrings))/numberofstrings;
	 
	 x = TMath::Cos(azimuth)*inscribingradius-48000;
	 y = TMath::Sin(azimuth)*inscribingradius;
	 
	 //G4cout << i << G4endl << "x: " << x << G4endl<< "y: " << y << G4endl << "z: " << z << G4endl << G4endl;
	 
	 detector_name = "phy_DetGeCrystal_";
	 detector_name += G4UIcommand::ConvertToString(i*4);
	 physical_ICPCdetector  = new G4PVPlacement(0,G4ThreeVector(x,y,z),logical_ICPCdetector,detector_name,logical_World,false,0,checkOverlaps);    
	 
	 detector_name = "phy_DetGeCrystal_";
	 detector_name += G4UIcommand::ConvertToString(i*4+1);
	 physical_ICPCdetector  = new G4PVPlacement(0,G4ThreeVector(x,y,z),logical_ICPCdetector,detector_name,logical_World,false,0,checkOverlaps);    
	 
	 detector_name = "phy_DetGeCrystal_";
	 detector_name += G4UIcommand::ConvertToString(i*4+2);
	 physical_ICPCdetector  = new G4PVPlacement(0,G4ThreeVector(x,y,z),logical_ICPCdetector,detector_name,logical_World,false,0,checkOverlaps);    
	 
	 detector_name = "phy_DetGeCrystal_";
	 detector_name += G4UIcommand::ConvertToString(i*4+3);
	 physical_ICPCdetector  = new G4PVPlacement(0,G4ThreeVector(x,y,z),logical_ICPCdetector,detector_name,logical_World,false,0,checkOverlaps);    
	 
       }
	 G4cout <<"Mass of one detector: " << logical_ICPCdetector->GetMass()/CLHEP::kg << G4endl; 
	 G4cout <<"Total mass of detectors: "  << (logical_ICPCdetector->GetMass()/CLHEP::kg)*numberofdetectors*4 << G4endl << G4endl; 
	 G4cout <<"Total volume of detectors (in cubic cm): "  << (logical_ICPCdetector->GetSolid()->GetCubicVolume()/CLHEP::cm3)*numberofdetectors*4 << G4endl << G4endl; 



     innerCopperCryostat = new G4Tubs("sol_innerCu",0*m, 0.5*m, 1*m, 0, 2*M_PI);
     innerLArShield = new G4Tubs("sol_innerLArShield",0*m, 0.49*m, 0.99*m, 0, 2*M_PI);
     //Gotta remove the LAr space from the copper, and the detector space from the LAr manually?
subsolid1 = new G4SubtractionSolid("sol1", innerCopperCryostat, innerLArShield,0, G4ThreeVector(0,0,0));
     
     logical_innerCopperCryostat1 = new G4LogicalVolume(subsolid1,mat_Cu,"log_innerCopperCryostat1");
     logical_innerCopperCryostat1->SetVisAttributes ( new G4VisAttributes(G4Colour(0.62, 0.3, 0.2,0.7) ));//Brown
     physical_innerCopperCryostat = new G4PVPlacement(0,G4ThreeVector(-44*m,0,16*m),logical_innerCopperCryostat1,"phy_innerCopperCryostat1",logical_World,false,0,checkOverlaps);
     
     logical_innerCopperCryostat2 = new G4LogicalVolume(subsolid1,mat_Cu,"log_innerCopperCryostat2");
     logical_innerCopperCryostat2->SetVisAttributes ( new G4VisAttributes(G4Colour(0.62, 0.3, 0.2,0.7) ));//Brown
     physical_innerCopperCryostat = new G4PVPlacement(0,G4ThreeVector(-46*m,0,16*m),logical_innerCopperCryostat2,"phy_innerCopperCryostat2",logical_World,false,0,checkOverlaps);
     
     logical_innerCopperCryostat3 = new G4LogicalVolume(subsolid1,mat_Cu,"log_innerCopperCryostat3");
     logical_innerCopperCryostat3->SetVisAttributes ( new G4VisAttributes(G4Colour(0.62, 0.3, 0.2,0.7) ));//Brown
     physical_innerCopperCryostat = new G4PVPlacement(0,G4ThreeVector(-45*m,1*m,16*m),logical_innerCopperCryostat3,"phy_innerCopperCryostat3",logical_World,false,0,checkOverlaps);
     
     logical_innerCopperCryostat4 = new G4LogicalVolume(subsolid1,mat_Cu,"log_innerCopperCryostat4");
     logical_innerCopperCryostat4->SetVisAttributes ( new G4VisAttributes(G4Colour(0.62, 0.3, 0.2,0.7) ));//Brown
     physical_innerCopperCryostat = new G4PVPlacement(0,G4ThreeVector(-45*m,-1*m,16*m),logical_innerCopperCryostat4,"phy_innerCopperCryostat4",logical_World,false,0,checkOverlaps);
     
     
     logical_innerLArShield1 = new G4LogicalVolume(innerLArShield,mat_ArLiq,"log_innerLArShield1");
     logical_innerLArShield1->SetVisAttributes ( new G4VisAttributes(G4Colour(0.1,0.9,0.1)) ); //green
     physical_innerLArShield = new G4PVPlacement(0,G4ThreeVector(-41*m,0,16*m),logical_innerLArShield1,"phy_innerLArShield1",logical_World,false,0,checkOverlaps);    
     
     logical_innerLArShield2 = new G4LogicalVolume(innerLArShield,mat_ArLiq,"log_innerLArShield2");
     logical_innerLArShield2->SetVisAttributes ( new G4VisAttributes(G4Colour(0.1,0.9,0.1)) ); //green
     physical_innerLArShield = new G4PVPlacement(0,G4ThreeVector(-43*m,0,16*m),logical_innerLArShield2,"phy_innerLArShield2",logical_World,false,0,checkOverlaps);    
     
     logical_innerLArShield3 = new G4LogicalVolume(innerLArShield,mat_ArLiq,"log_innerLArShield3");
     logical_innerLArShield3->SetVisAttributes ( new G4VisAttributes(G4Colour(0.1,0.9,0.1)) ); //green
     physical_innerLArShield = new G4PVPlacement(0,G4ThreeVector(-42*m,1*m,16*m),logical_innerLArShield3,"phy_innerLArShield3",logical_World,false,0,checkOverlaps);    
     
     logical_innerLArShield4 = new G4LogicalVolume(innerLArShield,mat_ArLiq,"log_innerLArShield4");
     logical_innerLArShield4->SetVisAttributes ( new G4VisAttributes(G4Colour(0.1,0.9,0.1)) ); //green
     physical_innerLArShield = new G4PVPlacement(0,G4ThreeVector(-42*m,-1*m,16*m),logical_innerLArShield4,"phy_innerLArShield4",logical_World,false,0,checkOverlaps);    
     
	 G4cout <<"Mass of one copper vessel: " << logical_innerCopperCryostat1->GetMass()/CLHEP::kg << G4endl; 
	 double LArmass = 0;
	 LArmass = (logical_innerLArShield1->GetSolid()->GetCubicVolume()/CLHEP::cm3) - (numberofdetectors*(logical_ICPCdetector->GetSolid()->GetCubicVolume()/CLHEP::cm3));
	 LArmass = LArmass*(logical_innerLArShield1->GetMaterial()->GetDensity()/CLHEP::kg*CLHEP::cm3);
	 G4cout <<"Mass of one inner liquid argon before adding detectors: " << logical_innerLArShield1->GetMass()/CLHEP::kg << G4endl; 
	 G4cout <<"After adding detectors (and displacing some LAr): " << LArmass << G4endl << G4endl;



     outerLArShield = new G4Tubs("sol_outerLArShield",0*m, 3.588*m, 3.588*m, 0, 2*M_PI);
subsolid1 = new G4SubtractionSolid("sol1", outerLArShield, innerCopperCryostat,0, G4ThreeVector(1*m,0,0));
subsolid2 = new G4SubtractionSolid("sol2", subsolid1, innerCopperCryostat,0, G4ThreeVector(-1*m,0,0));
subsolid3 = new G4SubtractionSolid("sol3", subsolid2, innerCopperCryostat,0, G4ThreeVector(0,1*m,0));
subsolid4 = new G4SubtractionSolid("sol4", subsolid3, innerCopperCryostat,0, G4ThreeVector(0,-1*m,0));
     
logical_outerLArShield = new G4LogicalVolume(subsolid4,mat_ArLiq,"log_outerLArShield");
     logical_outerLArShield->SetVisAttributes ( new G4VisAttributes(G4Colour(0.1,0.9,0.1)) ); //green
     physical_outerLArShield = new G4PVPlacement(0,G4ThreeVector(-36.5*m,0,14*m),logical_outerLArShield,"phy_outerLArShield",logical_World,false,0,checkOverlaps); 

     G4cout <<"Mass of outer liquid argon: " << logical_outerLArShield->GetMass()/CLHEP::kg << G4endl << G4endl; 



     outerSSVessel = new G4Tubs("sol_outerSS",0*m, 3.6*m, 3.6*m, 0, 2*M_PI);
 subsolid1 = new G4SubtractionSolid("sol1", outerSSVessel,outerLArShield,0, G4ThreeVector(0,0,0));    
     logical_outerSSVessel = new G4LogicalVolume(subsolid1,mat_316Ti,"log_outerSSVessel");
     logical_outerSSVessel->SetVisAttributes ( new G4VisAttributes(G4Colour(0.5, 0.5, 0.5,0.9) ));//Grey
     physical_outerSSVessel = new G4PVPlacement(0,G4ThreeVector(-29*m,0,14*m),logical_outerSSVessel,"phy_outerSSVessel",logical_World,false,0,checkOverlaps);

     G4cout <<"Mass of outer vessel: " << logical_outerSSVessel->GetMass()/CLHEP::kg << G4endl << G4endl; 



     upperLArShield = new G4Tubs("sol_upperLArShield",0*m, 0.988*m, 1.488*m, 0, 2*M_PI);
     logical_upperLArShield = new G4LogicalVolume(upperLArShield,mat_ArLiq,"log_upperLArShield");
     logical_upperLArShield->SetVisAttributes ( new G4VisAttributes(G4Colour(0.1,0.9,0.1)) ); //green
     physical_upperLArShield = new G4PVPlacement(0,G4ThreeVector(-24*m,0,16*m),logical_upperLArShield,"phy_upperLArShield",logical_World,false,0,checkOverlaps);

     G4cout <<"Mass of upper LAr tank: " << logical_upperLArShield->GetMass()/CLHEP::kg << G4endl << G4endl; 



     upperSSVessel = new G4Tubs("sol_upperSS",0*m, 1*m, 1.5*m, 0, 2*M_PI);
 subsolid1 = new G4SubtractionSolid("sol1", upperSSVessel,upperLArShield,0, G4ThreeVector(0,0,0));    
     logical_upperSSVessel = new G4LogicalVolume(subsolid1,mat_316Ti,"log_upperSSVessel");
     logical_upperSSVessel->SetVisAttributes ( new G4VisAttributes(G4Colour(0.5, 0.5, 0.5,0.9) ));//Grey
     physical_upperSSVessel = new G4PVPlacement(0,G4ThreeVector(-21.5*m,0,16*m),logical_upperSSVessel,"phy_upperSSVessel",logical_World,false,0,checkOverlaps);

     G4cout <<"Mass of upper SS vessel: " << logical_upperSSVessel->GetMass()/CLHEP::kg << G4endl << G4endl; 



     waterShield = new G4Box("sol_Water",6*m,6*m,6*m);
     subsolid2 = new G4SubtractionSolid("sol2", waterShield,upperSSVessel,0, G4ThreeVector(0,0,5.02*m));
     subsolid1 = new G4SubtractionSolid("sol1", subsolid2,outerSSVessel,0, G4ThreeVector(0,0,0));
     logical_waterShield = new G4LogicalVolume(subsolid1,mat_Water,"log_waterShield");
     logical_waterShield->SetVisAttributes ( new G4VisAttributes(G4Colour(0.3, 0.6, 1.0,0.2) ));//blue
     physical_waterShield = new G4PVPlacement(0,G4ThreeVector(-14*m,0,12*m),logical_waterShield,"phy_waterShield",logical_World,false,0,checkOverlaps);

     G4cout <<"Mass of water shield: " << logical_waterShield->GetMass()/CLHEP::kg << G4endl << G4endl << G4endl << G4endl;





     G4cout <<"pCDR2020 diagnostics:" << G4endl << G4endl << G4endl;

     innerCopperCryostat = new G4Tubs("sol_innerCu",0*m, 0.44*m, 2.800*m, 0, 2*M_PI);
     innerLArShield = new G4Tubs("sol_innerLArShield",0*m, 0.43*m, 2.790*m, 0, 2*M_PI);
          
     subsolid1 = new G4SubtractionSolid("sol1", innerCopperCryostat,innerLArShield,0, G4ThreeVector(0,0,0));
     logical_innerCopperCryostat1 = new G4LogicalVolume(subsolid1,mat_Cu,"log_innerCopperCryostat1");
     logical_innerCopperCryostat1->SetVisAttributes ( new G4VisAttributes(G4Colour(0.62, 0.3, 0.2,0.7) ));//Brown
     physical_innerCopperCryostat = new G4PVPlacement(0,G4ThreeVector(-44*m,0,-16*m),logical_innerCopperCryostat1,"phy_innerCopperCryostat1",logical_World,false,0,checkOverlaps);
     
     logical_innerCopperCryostat2 = new G4LogicalVolume(subsolid1,mat_Cu,"log_innerCopperCryostat2");
     logical_innerCopperCryostat2->SetVisAttributes ( new G4VisAttributes(G4Colour(0.62, 0.3, 0.2,0.7) ));//Brown
     physical_innerCopperCryostat = new G4PVPlacement(0,G4ThreeVector(-46*m,0,-16*m),logical_innerCopperCryostat2,"phy_innerCopperCryostat2",logical_World,false,0,checkOverlaps);
     
     logical_innerCopperCryostat3 = new G4LogicalVolume(subsolid1,mat_Cu,"log_innerCopperCryostat3");
     logical_innerCopperCryostat3->SetVisAttributes ( new G4VisAttributes(G4Colour(0.62, 0.3, 0.2,0.7) ));//Brown
     physical_innerCopperCryostat = new G4PVPlacement(0,G4ThreeVector(-45*m,1*m,-16*m),logical_innerCopperCryostat3,"phy_innerCopperCryostat3",logical_World,false,0,checkOverlaps);
     
     logical_innerCopperCryostat4 = new G4LogicalVolume(subsolid1,mat_Cu,"log_innerCopperCryostat4");
     logical_innerCopperCryostat4->SetVisAttributes ( new G4VisAttributes(G4Colour(0.62, 0.3, 0.2,0.7) ));//Brown
     physical_innerCopperCryostat = new G4PVPlacement(0,G4ThreeVector(-45*m,-1*m,-16*m),logical_innerCopperCryostat4,"phy_innerCopperCryostat4",logical_World,false,0,checkOverlaps);
     
     
     logical_innerLArShield1 = new G4LogicalVolume(innerLArShield,mat_ArLiq,"log_innerLArShield1");
     logical_innerLArShield1->SetVisAttributes ( new G4VisAttributes(G4Colour(0.1,0.9,0.1)) ); //green
     physical_innerLArShield = new G4PVPlacement(0,G4ThreeVector(-41*m,0,-16*m),logical_innerLArShield1,"phy_innerLArShield1",logical_World,false,0,checkOverlaps);    
     
     logical_innerLArShield2 = new G4LogicalVolume(innerLArShield,mat_ArLiq,"log_innerLArShield2");
     logical_innerLArShield2->SetVisAttributes ( new G4VisAttributes(G4Colour(0.1,0.9,0.1)) ); //green
     physical_innerLArShield = new G4PVPlacement(0,G4ThreeVector(-43*m,0,-16*m),logical_innerLArShield2,"phy_innerLArShield2",logical_World,false,0,checkOverlaps);    
     
     logical_innerLArShield3 = new G4LogicalVolume(innerLArShield,mat_ArLiq,"log_innerLArShield3");
     logical_innerLArShield3->SetVisAttributes ( new G4VisAttributes(G4Colour(0.1,0.9,0.1)) ); //green
     physical_innerLArShield = new G4PVPlacement(0,G4ThreeVector(-42*m,1*m,-16*m),logical_innerLArShield3,"phy_innerLArShield3",logical_World,false,0,checkOverlaps);    
     
     logical_innerLArShield4 = new G4LogicalVolume(innerLArShield,mat_ArLiq,"log_innerLArShield4");
     logical_innerLArShield4->SetVisAttributes ( new G4VisAttributes(G4Colour(0.1,0.9,0.1)) ); //green
     physical_innerLArShield = new G4PVPlacement(0,G4ThreeVector(-42*m,-1*m,-16*m),logical_innerLArShield4,"phy_innerLArShield4",logical_World,false,0,checkOverlaps);    

     
	 G4cout <<"Mass of one copper vessel: " << logical_innerCopperCryostat1->GetMass()/CLHEP::kg << G4endl; 
	 LArmass = 0;
	 LArmass = (logical_innerLArShield1->GetSolid()->GetCubicVolume()/CLHEP::cm3) - (numberofdetectors*(logical_ICPCdetector->GetSolid()->GetCubicVolume()/CLHEP::cm3));
	 LArmass = LArmass*(logical_innerLArShield1->GetMaterial()->GetDensity()/CLHEP::kg*CLHEP::cm3);
	 G4cout <<"Mass of one inner liquid argon before adding detectors: " << logical_innerLArShield1->GetMass()/CLHEP::kg << G4endl; 
	 G4cout <<"After adding detectors (and displacing some LAr): " << LArmass << G4endl << G4endl;


     //As per current design specs, the thickness of the side material is 15mm and the upper/lower material is 20mm
     outerLArShield = new G4Tubs("sol_outerLArShield",0*m, 3.485*m, 1.980*m, 0, 2*M_PI);
subsolid1 = new G4SubtractionSolid("sol1", outerLArShield, innerCopperCryostat,0, G4ThreeVector(1*m,0,1.15*m));
subsolid2 = new G4SubtractionSolid("sol2", subsolid1, innerCopperCryostat,0, G4ThreeVector(-1*m,0,1.15*m));
subsolid3 = new G4SubtractionSolid("sol3", subsolid2, innerCopperCryostat,0, G4ThreeVector(0,1*m,1.15*m));
subsolid4 = new G4SubtractionSolid("sol4", subsolid3, innerCopperCryostat,0, G4ThreeVector(0,-1*m,1.15*m));
     logical_outerLArShield = new G4LogicalVolume(subsolid4,mat_ArLiq,"log_outerLArShield");
     logical_outerLArShield->SetVisAttributes ( new G4VisAttributes(G4Colour(0.1,0.9,0.1)) ); //green
     physical_outerLArShield = new G4PVPlacement(0,G4ThreeVector(-36.5*m,0,-14*m),logical_outerLArShield,"phy_outerLArShield",logical_World,false,0,checkOverlaps); 

	 G4cout <<"Mass of outer liquid argon: " << logical_outerLArShield->GetMass()/CLHEP::kg << G4endl; 



    innerSSVessel = new G4Tubs("sol_innerSS",0*m, 3.5*m, 2*m, 0, 2*M_PI);
    subsolid1 = new G4SubtractionSolid("sol1", innerSSVessel,outerLArShield,0, G4ThreeVector(0,0,0));
     logical_innerSSVessel = new G4LogicalVolume(subsolid1,mat_316Ti,"log_innerSSVessel");
     logical_innerSSVessel->SetVisAttributes ( new G4VisAttributes(G4Colour(0.5, 0.5, 0.5,0.9) ));//Grey
     physical_innerSSVessel = new G4PVPlacement(0,G4ThreeVector(-29*m,0,-14*m),logical_innerSSVessel,"phy_innerSSVessel",logical_World,false,0,checkOverlaps);

     G4cout <<"Mass of inner steel vessel (which holds the outer liquid argon): " << logical_innerSSVessel->GetMass()/CLHEP::kg << G4endl << G4endl; 



     vacuumSpace = new G4Tubs("sol_vacuumSpace",0*m, 3.575*m, 3.574*m, 0, 2*M_PI);
     outerSSVessel = new G4Tubs("sol_outerSS",0*m, 3.6*m, 3.6*m, 0, 2*M_PI);
    subsolid1 = new G4SubtractionSolid("sol1", outerSSVessel,vacuumSpace,0, G4ThreeVector(0,0,0));
     logical_outerSSVessel = new G4LogicalVolume(subsolid1,mat_316Ti,"log_outerSSVessel");
     logical_outerSSVessel->SetVisAttributes ( new G4VisAttributes(G4Colour(0.5, 0.5, 0.5,0.9) ));//Grey
     physical_outerSSVessel = new G4PVPlacement(0,G4ThreeVector(-21.5*m,0,-14*m),logical_outerSSVessel,"phy_outerSSVessel",logical_World,false,0,checkOverlaps);

     G4cout <<"Mass of outer vessel: " << logical_outerSSVessel->GetMass()/CLHEP::kg << G4endl << G4endl; 



     SSChimney = new G4Tubs("sol_SSChimney",0.440*m,0.450*m,0.925*m,0,2*M_PI);
     logical_SSChimney = new G4LogicalVolume(SSChimney,mat_316Ti,"log_SSChimney");
     logical_SSChimney->SetVisAttributes ( new G4VisAttributes(G4Colour(0.5, 0.5, 0.5,0.9) ));//Grey
     physical_SSChimney = new G4PVPlacement(0,G4ThreeVector(-15*m,0.*m,-16*m),logical_SSChimney,"phy_SSChimney",logical_World,false,0,checkOverlaps);
     physical_SSChimney = new G4PVPlacement(0,G4ThreeVector(-17*m,0.*m,-16*m),logical_SSChimney,"phy_SSChimney",logical_World,false,1,checkOverlaps);
     physical_SSChimney = new G4PVPlacement(0,G4ThreeVector(-16*m,-1.*m,-16*m),logical_SSChimney,"phy_SSChimney",logical_World,false,2,checkOverlaps);
     physical_SSChimney = new G4PVPlacement(0,G4ThreeVector(-16*m,1.*m,-16*m),logical_SSChimney,"phy_SSChimney",logical_World,false,3,checkOverlaps);

     G4cout <<"Mass of one steel chimney: " << logical_SSChimney->GetMass()/CLHEP::kg << G4endl << G4endl; 



     waterShield = new G4Box("sol_Water",6*m,6*m,6*m);
     subsolid1 = new G4SubtractionSolid("sol1", waterShield,outerSSVessel,0, G4ThreeVector(0,0,0));
     subsolid2 = new G4SubtractionSolid("sol2", subsolid1,SSChimney,0, G4ThreeVector(1*m,0,4.525*m));
     subsolid3 = new G4SubtractionSolid("sol3", subsolid2,SSChimney,0, G4ThreeVector(-1*m,0,4.525*m));
     subsolid4 = new G4SubtractionSolid("sol4", subsolid3,SSChimney,0, G4ThreeVector(0,1*m,4.525*m));
     subsolid1 = new G4SubtractionSolid("sol1", subsolid4,SSChimney,0, G4ThreeVector(0,-1*m,4.525*m));
     subsolid2 = new G4SubtractionSolid("sol2", subsolid1,innerCopperCryostat,0, G4ThreeVector(1*m,0,2.65*m));
     subsolid3 = new G4SubtractionSolid("sol3", subsolid2,innerCopperCryostat,0, G4ThreeVector(-1*m,0,2.65*m));
     subsolid4 = new G4SubtractionSolid("sol4", subsolid3,innerCopperCryostat,0, G4ThreeVector(0,1*m,2.65*m));
     subsolid1 = new G4SubtractionSolid("sol1", subsolid4,innerCopperCryostat,0, G4ThreeVector(0,-1*m,2.65*m));
     logical_waterShield = new G4LogicalVolume(subsolid1,mat_Water,"log_waterShield");
     logical_waterShield->SetVisAttributes ( new G4VisAttributes(G4Colour(0.3, 0.6, 1.0,0.2) ));//blue
     physical_waterShield = new G4PVPlacement(0,G4ThreeVector(-8*m,0,-12*m),logical_waterShield,"phy_waterShield",logical_World,false,0,checkOverlaps);

     G4cout <<"Mass of water shield: " << logical_waterShield->GetMass()/CLHEP::kg << G4endl << G4endl;



     polysolid = new G4Tubs("sol_polysolid",0*m,2*m,2*m,0,2*M_PI);
     Gd2O3solid = new G4Tubs("sol_Gd2O3solid",0*m,1.9*m,1.9*m,0,2*M_PI);
     subtractGd2O3 = new G4Tubs("sub_Gd2O3",0*m,1.895*m,1.895*m,0,2*M_PI);
     polyshield = new G4SubtractionSolid("out_polyshield", polysolid, Gd2O3solid ,0 , G4ThreeVector(0,0,0));
     Gd2O3shield = new G4SubtractionSolid("out_Gd2O3shield", Gd2O3solid, subtractGd2O3 ,0 , G4ThreeVector(0,0,0));
     logical_polyshield = new G4LogicalVolume(polyshield,mat_poly,"log_polyshield");
     logical_polyshield->SetVisAttributes ( new G4VisAttributes(G4Colour(0.9,0.9,0.1)) ); //yellow
     logical_Gd2O3shield = new G4LogicalVolume(Gd2O3shield,mat_Gd2O3,"log_Gd2O3shield");
     logical_Gd2O3shield->SetVisAttributes ( new G4VisAttributes(G4Colour(1.0,1.0,1.0)) ); //white
     physical_polyshield = new G4PVPlacement(0,G4ThreeVector(-47*m,0,0),logical_polyshield,"phy_polyshield",logical_World,false,0,checkOverlaps);
     physical_Gd2O3shield = new G4PVPlacement(0,G4ThreeVector(-43*m,0,0),logical_Gd2O3shield,"phy_Gd2O3shield",logical_World,false,0,checkOverlaps);
     
     G4cout <<"Mass of undoped poly shield: " << logical_polyshield->GetMass()/CLHEP::kg << G4endl;
     G4cout <<"Mass of gadolinium coating: " << logical_Gd2O3shield->GetMass()/CLHEP::kg << G4endl;

     logical_polyshield = new G4LogicalVolume(polyshield,mat_boratedpoly,"log_polyshield");
     logical_polyshield->SetVisAttributes ( new G4VisAttributes(G4Colour(0.7,0.5,0.2)) ); //brown
     physical_polyshield = new G4PVPlacement(0,G4ThreeVector(-39*m,0,0),logical_polyshield,"phy_polyshield",logical_World,false,0,checkOverlaps);

     G4cout <<"Mass of boron doped poly shield: " << logical_polyshield->GetMass()/CLHEP::kg << G4endl << G4endl << G4endl << G4endl;


     return physical_World;

}//Diagnostic



/*
Uncomment the first block and move it into a pCDR-compatible geometry in order to implement the poly/Gd neutron shield
Uncomment the second block and move it into a pCDR-compatible geometry in order to implement the borated poly shield
Implemented on Bernhard's request December 2019-Jan2020

polysolid = new G4Tubs("sol_polysolid",0*m,2*m,2*m,0,2*M_PI);
Gd2O3solid = new G4Tubs("sol_Gd2O3solid",0*m,1.9*m,1.9*m,0,2*M_PI);
subtractGd2O3 = new G4Tubs("sub_Gd2O3",0*m,1.895*m,1.895*m,0,2*M_PI);
polyshield = new G4SubtractionSolid("out_polyshield", polysolid, Gd2O3solid ,0 , G4ThreeVector(0,0,0));
Gd2O3shield = new G4SubtractionSolid("out_Gd2O3shield", Gd2O3solid, subtractGd2O3 ,0 , G4ThreeVector(0,0,0));
logical_polyshield = new G4LogicalVolume(polyshield,mat_poly,"log_polyshield");
logical_polyshield->SetVisAttributes ( new G4VisAttributes(G4Colour(0.9,0.9,0.1)) ); //yellow
logical_Gd2O3shield = new G4LogicalVolume(Gd2O3shield,mat_Gd2O3,"log_Gd2O3shield");
logical_Gd2O3shield->SetVisAttributes ( new G4VisAttributes(G4Colour(1.0,1.0,1.0)) ); //white
physical_polyshield = new G4PVPlacement(0,G4ThreeVector(0,0,0),logical_polyshield,"phy_polyshield",logical_outerLArShield,false,0,checkOverlaps);
physical_Gd2O3shield = new G4PVPlacement(0,G4ThreeVector(0,0,0),logical_Gd2O3shield,"phy_Gd2O3shield",logical_outerLArShield,false,0,checkOverlaps);



G4cout << "Poly shield with 5% boron doping, to follow up the Gd shielding option" << G4endl;
polysolid = new G4Tubs("sol_polysolid",0*m,2*m,2*m,0,2*M_PI);
Gd2O3solid = new G4Tubs("sol_Gd2O3solid",0*m,1.9*m,1.9*m,0,2*M_PI);
polyshield = new G4SubtractionSolid("out_polyshield", polysolid, Gd2O3solid ,0 , G4ThreeVector(0,0,0));
logical_polyshield = new G4LogicalVolume(polyshield,mat_boratedpoly,"log_polyshield");
logical_polyshield->SetVisAttributes ( new G4VisAttributes(G4Colour(0.7,0.5,0.2)) ); //brown, hopefully
physical_polyshield = new G4PVPlacement(0,G4ThreeVector(0,0,0),logical_polyshield,"phy_polyshield",logical_outerLArShield,false,0,checkOverlaps);
*/

/*
To be implemented when the user wants a 'wrapper' around each of the detector arrays.
Implemented 2-15-20, only compatible with pCDR2020 geometry at time of writing

     //Array dimensions are currently:
     //Highest z value:-1225
     //Lowest z value:-2475
     //Height: (2475-1225+2*37.5)=1325 mm
     //Highest x value: 375
     //Lowest x value:-370
     //Highest y value:374
     //Lowest y value:-374
     //Let's just make things simple by making it radius 375+45=420 mm blaze it
     //Surface area for one cylinder = pi*1325*420*420=4.604947 square meters
     //Surface area for all cylinders = 18.419786 square meters
     //When reporting I can just use 4.6 and 18.4
     //Volume for one cylinder: 0.734284451 cubic meters
     //Volume for all cylinders: 2.937137804 cubic meters
     //Can just use 0.74 and 2.9 in reporting

     //Central x and y value for each array: 0
     //Central z value: -1850


     wrapsolid  = new G4Tubs("sol_wrap",0*m, 420*mm, 662.5*mm, 0, 2*M_PI);
     logical_wrap  = new G4LogicalVolume(wrapsolid,mat_Detector,"log_wrap");
     logical_wrap->SetVisAttributes ( new G4VisAttributes(G4Colour(0.6,0.1,0.6)) );//Purple
          physical_wrap = new G4PVPlacement(0,G4ThreeVector(0,0,-1850*mm),logical_wrap,"phy_wrap1",logical_innerLArShield1,false,0,checkOverlaps);    
          physical_wrap = new G4PVPlacement(0,G4ThreeVector(0,0,-1850*mm),logical_wrap,"phy_wrap2",logical_innerLArShield2,false,1,checkOverlaps);    
          physical_wrap = new G4PVPlacement(0,G4ThreeVector(0,0,-1850*mm),logical_wrap,"phy_wrap3",logical_innerLArShield3,false,2,checkOverlaps);    
          physical_wrap = new G4PVPlacement(0,G4ThreeVector(0,0,-1850*mm),logical_wrap,"phy_wrap4",logical_innerLArShield4,false,3,checkOverlaps);

     return physical_World;



//Alternative design, where the wrapper is permeable. Make sure to change the detector array behavior as well
//when implementing this (change the z offset and their mother ligcal volume)

     wrapsolid  = new G4Tubs("sol_wrap",0*m, 420*mm, 662.5*mm, 0, 2*M_PI);
     logical_wrap1  = new G4LogicalVolume(wrapsolid,mat_ArLiq,"log_wrap1");
     logical_wrap1->SetVisAttributes ( new G4VisAttributes(G4Colour(0.6,0.1,0.6)) );//Purple
     logical_wrap2  = new G4LogicalVolume(wrapsolid,mat_ArLiq,"log_wrap2");
     logical_wrap2->SetVisAttributes ( new G4VisAttributes(G4Colour(0.6,0.1,0.6)) );//Purple
     logical_wrap3  = new G4LogicalVolume(wrapsolid,mat_ArLiq,"log_wrap3");
     logical_wrap3->SetVisAttributes ( new G4VisAttributes(G4Colour(0.6,0.1,0.6)) );//Purple
     logical_wrap4  = new G4LogicalVolume(wrapsolid,mat_ArLiq,"log_wrap4");
     logical_wrap4->SetVisAttributes ( new G4VisAttributes(G4Colour(0.6,0.1,0.6)) );//Purple
     physical_wrap = new G4PVPlacement(0,G4ThreeVector(0,0,-1850*mm),logical_wrap1,"phy_wrap1",logical_innerLArShield1,false,0,checkOverlaps);    
     physical_wrap = new G4PVPlacement(0,G4ThreeVector(0,0,-1850*mm),logical_wrap2,"phy_wrap2",logical_innerLArShield2,false,1,checkOverlaps);    
     physical_wrap = new G4PVPlacement(0,G4ThreeVector(0,0,-1850*mm),logical_wrap3,"phy_wrap3",logical_innerLArShield3,false,2,checkOverlaps);    
     physical_wrap = new G4PVPlacement(0,G4ThreeVector(0,0,-1850*mm),logical_wrap4,"phy_wrap4",logical_innerLArShield4,false,3,checkOverlaps);

 */
