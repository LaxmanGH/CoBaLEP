//Rock optioning

//Must declare all variables outside of the conditional statements

//Original rock variables
G4Tubs* solid_CutOut;
G4SubtractionSolid *solid_Rock2;//Lab cut out
G4SubtractionSolid *solid_Rock3;//Detector space cut out
G4LogicalVolume* logical_Rock;
G4VPhysicalVolume* physical_Rock;

//Trig testing variables
G4Tubs* innerer_CutOut;
G4Tubs* innerer_Rock;
//Original rock with range cuts variables

G4Tubs* inner_CutOut; //Space for detectors and inner rock region
G4SubtractionSolid *outer_Rock; //Outer rock with inner cutout removed
G4SubtractionSolid *outer_Rock2;//Inner cutout AND lab space removed
G4LogicalVolume* logical_outerRock;
G4VPhysicalVolume* physical_outerRock;
G4LogicalVolume* logical_solidRock;
G4VPhysicalVolume* physical_solidRock;
G4Tubs* inner_Rock;//Inner rock
G4SubtractionSolid* inner_Rock2;//Inner rock with lab space removed
G4LogicalVolume* logical_innerRock;
G4VPhysicalVolume* physical_innerRock;
G4Region *OuterRockRegion;//For range cuts
G4Region *InnerRockRegion;//For range cuts

//For LAR studies
G4Tubs *inner_Argon;
G4Tubs *outer_Copper;
G4LogicalVolume *logical_Argon;
G4LogicalVolume *logical_Copper;
G4VPhysicalVolume *physical_Argon;
G4VPhysicalVolume *physical_Copper;

//For new pCDR geometry
G4Box *waterShield;
G4LogicalVolume *logical_waterShield;
G4VPhysicalVolume *physical_waterShield;
G4Tubs *outerCopperCryostat;
G4LogicalVolume *logical_outerCopperCryostat;
G4VPhysicalVolume *physical_outerCopperCryostat;
G4Tubs *upperCopperCryostat;
G4LogicalVolume *logical_upperCopperCryostat;
G4VPhysicalVolume *physical_upperCopperCryostat;
G4Tubs *outerLarShield;
G4LogicalVolume *logical_outerLarShield;
G4VPhysicalVolume *physical_outerLarShield;
G4Tubs *upperLarShield;
G4LogicalVolume *logical_upperLarShield;
G4VPhysicalVolume *physical_upperLarShield;
G4Tubs *innerCopperCryostat;
G4LogicalVolume *logical_innerCopperCryostat1;
G4LogicalVolume *logical_innerCopperCryostat2;
G4LogicalVolume *logical_innerCopperCryostat3;
G4LogicalVolume *logical_innerCopperCryostat4;
G4VPhysicalVolume *physical_innerCopperCryostat;
G4Tubs *innerLarShield;
G4LogicalVolume *logical_innerLarShield1;
G4LogicalVolume *logical_innerLarShield2;
G4LogicalVolume *logical_innerLarShield3;
G4LogicalVolume *logical_innerLarShield4;
G4VPhysicalVolume *physical_innerLarShield;
G4Tubs *ICPCshell;
G4Tubs *borehole;
G4SubtractionSolid *ICPCdetector;
G4LogicalVolume *logical_ICPCdetector;
G4VPhysicalVolume *physical_ICPCdetector;

G4Box* solid_Rock; //= new G4Box("sol_Rock",50*m,50*m,30*m);
G4Box* solid_Lab; //= new G4Box("sol_Lab",35*m,10*m,4*m);



if(RockOption == "OriginalWithRock")//Original rock definition
  {//Rock is all one big shape, with holes cut out for lab and detector

    G4cout << G4endl <<  "OriginalWithRock: using rock at SURF without range cuts..." << G4endl << G4endl;

    solid_Rock = new G4Box("sol_Rock",50*m,50*m,30*m);
    solid_Lab = new G4Box("sol_Lab",35*m,10*m,4*m);
    
    solid_Rock2 = new G4SubtractionSolid("sol_Rock2", solid_Rock, solid_Lab ,0 , G4ThreeVector(-25*m,0,10.5*m));
    solid_CutOut = new G4Tubs("sol_CutOut",0, 6.50001*m ,6.50001*m, 0, 2*M_PI);
    solid_Rock3 = new G4SubtractionSolid("sol_Rock3", solid_Rock2, solid_CutOut ,0 , G4ThreeVector(0,0,0));

  logical_Rock = new G4LogicalVolume(solid_Rock3,mat_Rock,"log_Rock");
  logical_Rock->SetVisAttributes ( new G4VisAttributes(G4Colour(0.7, 0.7, 0.7, 0.5) )); //grey 50% transparent
  physical_Rock = new G4PVPlacement(0,G4ThreeVector(),logical_Rock,"phy_Rock",logical_World,false,0,checkOverlaps);
  
  }//OldRock


 else if(RockOption=="NewRock")
  {
    G4cout << G4endl << "OriginalWithRangeCuts: using rock at SURF with range cuts..." << G4endl << G4endl;

    solid_Rock = new G4Box("sol_Rock",50*m,50*m,30*m);
    solid_Lab = new G4Box("sol_Lab",35*m,10*m,4*m);

    
    //Separate the rock into two regions
    //The region closer to the detector will have better position res.

    inner_CutOut = new G4Tubs("inn_CutOut",0*m, 11.5*m, 11.5*m,0, 2*M_PI);

    outer_Rock = new G4SubtractionSolid("out_Rock", solid_Rock, solid_Lab ,0 , G4ThreeVector(-25*m,0,10.5*m));//cut out lab
    
    outer_Rock2 = new G4SubtractionSolid("out_Rock2", outer_Rock, inner_CutOut ,0 , G4ThreeVector(0,0,0));//cut out assembly and innerrock
    
    inner_Rock = new G4Tubs("inn_Rock",6.50001*m, 11.49999*m, 11.49999*m, 0, 2*M_PI); //assembly already cut out
    
    inner_Rock2 = new G4SubtractionSolid("inn_Rock2", inner_Rock, solid_Lab ,0 , G4ThreeVector(-25*m,0,10.5*m));//cut out lab
    
    logical_outerRock = new G4LogicalVolume(outer_Rock2,mat_Rock,"log_outRock");
    
    logical_outerRock->SetVisAttributes ( new G4VisAttributes(G4Colour(0.7, 0.7, 0.7, 0.5) )); //grey 50% transparent
    
    physical_outerRock = new G4PVPlacement(0,G4ThreeVector(),logical_outerRock,"phy_outerRock",logical_World,false,0,checkOverlaps);
    
    logical_innerRock = new G4LogicalVolume(inner_Rock2,mat_Rock,"log_innRock");
    
    logical_innerRock->SetVisAttributes ( new G4VisAttributes(G4Colour(0.7, 0.7, 0.7, 0.5) )); //grey 50% transparent
    
    physical_innerRock = new G4PVPlacement(0,G4ThreeVector(),logical_innerRock,"phy_innerRock",logical_World,false,0,checkOverlaps);
    
    
    //Define regions for custom range cuts in macro
    OuterRockRegion = new G4Region("OuterRockRegion");
    OuterRockRegion-> AddRootLogicalVolume(logical_outerRock);
    InnerRockRegion = new G4Region("InnerRockRegion");
    InnerRockRegion-> AddRootLogicalVolume(logical_innerRock);

  }//NewRock

 else if(RockOption == "September2018WithCuts")
   {
     //September 2018 geometry changes implemented
    G4cout << G4endl << "September2018WithCuts: using rock at SURF with range cuts and September2018 geometry..." << G4endl << G4endl;

        assemblyzoffset = -6.5*m;

     solid_Rock = new G4Box("sol_Rock",32.5*m,15*m,18*m);
     solid_Lab = new G4Box("sol_Lab",30*m,10*m,4*m);

     //Separate the rock into two regions
     //The region closer to the detector will have better position res.

    inner_CutOut = new G4Tubs("inn_CutOut",0*m, 11.5*m, 11.5*m,0, 2*M_PI);

    outer_Rock = new G4SubtractionSolid("out_Rock", solid_Rock, solid_Lab ,0 , G4ThreeVector(-2.5*m,0,4*m));//cut out lab
    
    outer_Rock2 = new G4SubtractionSolid("out_Rock2", outer_Rock, inner_CutOut ,0 , G4ThreeVector(17.5*m,0,-6.5*m));//cut out inner rock and assembly
    
    inner_Rock = new G4Tubs("inn_Rock",6.50001*m, 11.49999*m, 11.49999*m, 0, 2*M_PI); //assembly already cut out
    
    inner_Rock2 = new G4SubtractionSolid("inn_Rock2", inner_Rock, solid_Lab ,0 , G4ThreeVector(-20*m,0,10.5*m));//cut out lab
    
    logical_outerRock = new G4LogicalVolume(outer_Rock2,mat_Rock,"log_outRock");
    
    logical_outerRock->SetVisAttributes ( new G4VisAttributes(G4Colour(0.7, 0.7, 0.7, 0.5) )); //grey 50% transparent
    
    physical_outerRock = new G4PVPlacement(0,G4ThreeVector(-17.5*m,0,0),logical_outerRock,"phy_outerRock",logical_World,false,0,checkOverlaps);
    
    logical_innerRock = new G4LogicalVolume(inner_Rock2,mat_Rock,"log_innRock");
    
    logical_innerRock->SetVisAttributes ( new G4VisAttributes(G4Colour(0.7, 0.7, 0.7, 0.5) )); //grey 50% transparent
    
    physical_innerRock = new G4PVPlacement(0,G4ThreeVector(0,0,-6.5*m),logical_innerRock,"phy_innerRock",logical_World,false,0,checkOverlaps);
    
    
    //Define regions for custom range cuts in macro
    OuterRockRegion = new G4Region("OuterRockRegion");
    OuterRockRegion-> AddRootLogicalVolume(logical_outerRock);
    InnerRockRegion = new G4Region("InnerRockRegion");
    InnerRockRegion-> AddRootLogicalVolume(logical_innerRock);
   }

else if(RockOption == "GeOnly")
{
G4cout << "It's Germanium all the way down..." << G4endl;
//Study of neutrons on Ge
G4Tubs *GeColumn = new G4Tubs("Ge_column",0*m, 10*m, 10*m,0, 2*M_PI);
//Create a cylinder of Ge 20m tall, 20m in diameter of detector-grade Ge
//Should be overkill, but including extra Ge doesn't affect runtime
G4LogicalVolume *logicalGe = new G4LogicalVolume(GeColumn,mat_Detector,"log_Ge");
logicalGe->SetVisAttributes ( new G4VisAttributes(G4Colour(0.1,0.9,0.1)));
G4PVPlacement *physicalGe = new G4PVPlacement(0,G4ThreeVector(0,0,0),logicalGe,"phyGe",logical_World,false,0,checkOverlaps);
     return physical_World;
}

 else if(RockOption == "TrigStudy")
{
G4cout << "Trig study" << G4endl;

        assemblyzoffset = -6.5*m;

     solid_Rock = new G4Box("sol_Rock",32.5*m,15*m,18*m);
     solid_Lab = new G4Box("sol_Lab",30*m,10*m,4*m);

     //Separate the rock into two regions
     //The region closer to the detector will have better position res.

    //inner_CutOut = new G4Tubs("inn_CutOut",0*m, 11.5*m, 11.5*m,0, 2*M_PI);
innerer_CutOut = new G4Tubs("inn_CutOut",0*m, 11.50001*m, 11.50001*m,0, 2*M_PI);//G4Box("inn_CutOut",11.5*m, 11.5*m, 11.5*m);
    outer_Rock = new G4SubtractionSolid("out_Rock", solid_Rock, solid_Lab ,0 , G4ThreeVector(-2.5*m,0,4*m));//cut out lab
    
    outer_Rock2 = new G4SubtractionSolid("out_Rock2", outer_Rock, innerer_CutOut ,0 , G4ThreeVector(17.5*m,0,-6.5*m));//cut out inner rock and assembly
    
    //inner_Rock = new G4Tubs("inn_Rock",0*m, 11.49999*m, 11.49999*m, 0, 2*M_PI); //assembly already cut out

innerer_Rock = new G4Tubs("inn_CutOut",0*m, 11.5*m, 11.5*m,0, 2*M_PI);//G4Box("inn_Rock", 11.49999*m, 11.49999*m, 11.49999*m);    

    inner_Rock2 = new G4SubtractionSolid("inn_Rock2", inner_Rock, solid_Lab ,0 , G4ThreeVector(-20*m,0,10.5*m));//cut out lab
    
    logical_outerRock = new G4LogicalVolume(outer_Rock2,mat_Rock,"log_outRock");
    
    logical_outerRock->SetVisAttributes ( new G4VisAttributes(G4Colour(0.7, 0.7, 0.7, 0.5) )); //grey 50% transparent
    
    physical_outerRock = new G4PVPlacement(0,G4ThreeVector(-17.5*m,0,0),logical_outerRock,"phy_outerRock",logical_World,false,0,checkOverlaps);
    
    logical_innerRock = new G4LogicalVolume(innerer_Rock,mat_Rock,"log_innRock");
    
    logical_innerRock->SetVisAttributes ( new G4VisAttributes(G4Colour(0.7, 0.7, 0.7, 0.5) )); //grey 50% transparent
    
    physical_innerRock = new G4PVPlacement(0,G4ThreeVector(0,0,-6.5*m),logical_innerRock,"phy_innerRock",logical_World,false,0,checkOverlaps);


return physical_World;

}

else if (RockOption == "LArStudy")
  {//Study of muon products in liquid argon (especially neutrons)
    G4cout << "LAr pathlength studies (should probably be deprecated)" << G4endl;
    assemblyzoffset = -6.5*m;

inner_Argon= new G4Tubs("inn_Argon",0*m, 3.95*m, 3.95*m,0, 2*M_PI);
outer_Copper = new G4Tubs("inn_Copper",0*m, 4*m, 4*m,0, 2*M_PI);
logical_Argon = new G4LogicalVolume(inner_Argon,mat_ArLiq,"log_Argon");
logical_Argon->SetVisAttributes ( new G4VisAttributes(G4Colour(0.8, 0.0, 0.8,0.1) ));
logical_Copper = new G4LogicalVolume(outer_Copper,mat_Cu,"log_Copper");
logical_Copper->SetVisAttributes ( new G4VisAttributes(G4Colour(0.62, 0.3, 0.2,0.7) ));
physical_Copper = new G4PVPlacement(0,G4ThreeVector(0,0,assemblyzoffset),logical_Copper,"phy_Copper",logical_World,false,0,checkOverlaps);
physical_Argon = new G4PVPlacement(0,G4ThreeVector(0,0,0),logical_Argon,"phy_Argon",logical_Copper,false,0,checkOverlaps);

return physical_World;

  }		 

 else if(RockOption == "March2019WithCuts")
   {
     //Excess rock removed, world xy volume same size for sake of sampling plane
     solid_Rock = new G4Box("sol_Rock",32.499999*m,15*m,9*m);
     solid_Lab = new G4Box("sol_Lab",30*m,10*m,4*m);
     assemblyzoffset = -4*m;

     //Separate the rock into two regions
     //The region closer to the detector will have better position res.

    inner_CutOut = new G4Tubs("inn_CutOut",0*m, 11.5*m, 11.5*m,0, 2*M_PI);

    outer_Rock = new G4SubtractionSolid("out_Rock", solid_Rock, solid_Lab ,0 , G4ThreeVector(-5*m,0,0));//cut out lab from top rock
    
    outer_Rock2 = new G4SubtractionSolid("out_Rock2", outer_Rock, inner_CutOut ,0 , G4ThreeVector(17.5*m,0,-10.5*m));//cut out inner rock and assembly
    
    inner_Rock = new G4Tubs("inn_Rock",6.50001*m, 11.49999*m, 11.49999*m, 0, 2*M_PI); //assembly already cut out
    
    inner_Rock2 = new G4SubtractionSolid("inn_Rock2", inner_Rock, solid_Lab ,0 , G4ThreeVector(-20*m,0,10.5*m));//cut out lab from inner rock
    
    logical_outerRock = new G4LogicalVolume(outer_Rock2,mat_Rock,"log_outRock");
    
    logical_outerRock->SetVisAttributes ( new G4VisAttributes(G4Colour(0.7, 0.7, 0.7, 0.5) )); //grey 50% transparent
    
    physical_outerRock = new G4PVPlacement(0,G4ThreeVector(-17.5*m,0,6.5*m),logical_outerRock,"phy_outerRock",logical_World,false,0,checkOverlaps);
    
    logical_innerRock = new G4LogicalVolume(inner_Rock2,mat_Rock,"log_innRock");
    
    logical_innerRock->SetVisAttributes ( new G4VisAttributes(G4Colour(0.7, 0.7, 0.7, 0.5) )); //grey 50% transparent
    
    physical_innerRock = new G4PVPlacement(0,G4ThreeVector(0,0,-4*m),logical_innerRock,"phy_innerRock",logical_World,false,0,checkOverlaps);
    
    
    //Define regions for custom range cuts in macro
    OuterRockRegion = new G4Region("OuterRockRegion");
    OuterRockRegion-> AddRootLogicalVolume(logical_outerRock);
    InnerRockRegion = new G4Region("InnerRockRegion");
    InnerRockRegion-> AddRootLogicalVolume(logical_innerRock);
   }


 else if(RockOption == "NeutronMultiplicityValidation")
   {
    G4cout << G4endl << "NeutronMultiplicityValidation: Running a neutron multiplicity study geometry, with pure rock..." << G4endl << G4endl;
     //For validating the multiplicity of neutron showers with out module setup.
     G4Box* solid_innerWorld = new G4Box("sol_innerWorld",30*m,30*m,12*m);	  
     G4LogicalVolume* logical_innerWorld = new G4LogicalVolume(solid_innerWorld,mat_vacuum,"log_innerWorld");
     logical_innerWorld->SetVisAttributes (G4VisAttributes::Invisible);
G4VPhysicalVolume* physical_innerWorld  = new G4PVPlacement(0,G4ThreeVector(),logical_innerWorld,"phy_innerWorld",logical_World,false,0,checkOverlaps);

     G4Box* solid_neutronRock = new G4Box("sol_neutronRock",.5*cm,10*m,10*m);
     G4LogicalVolume* logical_neutronRock = new G4LogicalVolume(solid_neutronRock,mat_Rock,"log_neutronRock");
     logical_neutronRock->SetVisAttributes ( new G4VisAttributes(G4Colour(0.7, 0.7, 0.7, 0.5) )); //grey 50% transparent
G4VPhysicalVolume* physical_neutronRock;
 G4String rock_name;
 G4ThreeVector rock_position;
 for(int j = 1;j<2001;j++)
   {
     rock_name = "phy_neutronRock";
     rock_name+=G4UIcommand::ConvertToString(j);
     rock_position = G4ThreeVector(j*cm,0,0);
     new G4PVPlacement(0,rock_position,logical_neutronRock,rock_name,logical_innerWorld,false,j,checkOverlaps);
   }



     return physical_World;
   }

 else if(RockOption=="LArColumn")
   {
     //Simple column of LAr separated into slabs, for shower study
     G4cout << "LAr showering study" << G4endl << G4endl;
     G4Box* solid_neutronLAr = new G4Box("sol_neutronLAr",.5*cm,10*m,10*m);
     G4LogicalVolume* logical_neutronLAr = new G4LogicalVolume(solid_neutronLAr,mat_ArLiq,"log_neutronLAr");
     logical_neutronLAr->SetVisAttributes ( new G4VisAttributes(G4Colour(0.1,0.9,0.1) )); //green
     G4VPhysicalVolume* physical_neutronLAr;
     G4String LAr_name;
     G4ThreeVector LAr_position;
     for(int j = 1;j<2001;j++)
       {
	 LAr_name = "phy_neutronLAr";
	 LAr_name+=G4UIcommand::ConvertToString(j);
	 LAr_position = G4ThreeVector(j*cm,0,0);
	 new G4PVPlacement(0,LAr_position,logical_neutronLAr,LAr_name,logical_World,false,j,checkOverlaps);
       } 
     return physical_World;
   }

 else if (RockOption=="pCDR")
   {
     G4cout << "Work in progress attempt to make a geometry closely resembling the pCDR's current status..." << G4endl << G4endl;
     

     solid_Rock = new G4Box("sol_Rock",11*m,11*m,13*m);
     solid_Lab = new G4Box("sol_Lab",6*m,6*m,8*m);
    outer_Rock = new G4SubtractionSolid("out_Rock", solid_Rock, solid_Lab ,0 , G4ThreeVector(0,0,0));//cut out lab space from rock
    logical_outerRock = new G4LogicalVolume(outer_Rock,mat_Rock,"log_outRock");
    logical_outerRock->SetVisAttributes ( new G4VisAttributes(G4Colour(0.7, 0.7, 0.7, 0.5) )); //grey 50% transparent    
    physical_outerRock = new G4PVPlacement(0,G4ThreeVector(0,0,2*m),logical_outerRock,"phy_outerRock",logical_World,false,0,checkOverlaps);

    //Add general assembly of shielding

    waterShield = new G4Box("sol_Water",6*m,6*m,6*m);
logical_waterShield = new G4LogicalVolume(waterShield,mat_Water,"log_waterShield");
 logical_waterShield->SetVisAttributes ( new G4VisAttributes(G4Colour(0.3, 0.6, 1.0,0.2) ));//blue hopefully
    physical_waterShield = new G4PVPlacement(0,G4ThreeVector(0,0,0),logical_waterShield,"phy_waterShield",logical_World,false,0,checkOverlaps);

    outerSSCryostat = new G4Tubs("sol_outerCu",0*m, 3.5*m, 3.5*m, 0, 2*M_PI);
logical_outerSSCryostat = new G4LogicalVolume(outerSSCryostat,mat_316Ti,"log_outerSSCryostat");
 logical_outerSSCryostat->SetVisAttributes ( new G4VisAttributes(G4Colour(0.5, 0.5, 0.5,0.9) ));//Grey
physical_outerSSCryostat = new G4PVPlacement(0,G4ThreeVector(0,0,0),logical_outerSSCryostat,"phy_outerSSCryostat",logical_waterShield,false,0,checkOverlaps);

    upperSSCryostat = new G4Tubs("sol_upperCu",0*m, 1*m, 1.5*m, 0, 2*M_PI);
    logical_upperSSCryostat = new G4LogicalVolume(upperSSCryostat,mat_316Ti,"log_upperSSCryostat");
    logical_upperSSCryostat->SetVisAttributes ( new G4VisAttributes(G4Colour(0.5, 0.5, 0.5,0.9) ));//Grey
    physical_upperSSCryostat = new G4PVPlacement(0,G4ThreeVector(0,0,5.02*m),logical_upperSSCryostat,"phy_upperSSCryostat",logical_waterShield,false,0,checkOverlaps);

    outerLarShield = new G4Tubs("sol_outerLarShield",0*m, 3.488*m, 3.488*m, 0, 2*M_PI);
    logical_outerLarShield = new G4LogicalVolume(outerLarShield,mat_ArLiq,"log_outerLarShield");
    logical_outerLarShield->SetVisAttributes ( new G4VisAttributes(G4Colour(0.1,0.9,0.1)) ); //green
    physical_outerLarShield = new G4PVPlacement(0,G4ThreeVector(0,0,0),logical_outerLarShield,"phy_outerLarShield",logical_outerSSCryostat,false,0,checkOverlaps);    

    upperLarShield = new G4Tubs("sol_upperLarShield",0*m, 0.988*m, 1.488*m, 0, 2*M_PI);
    logical_upperLarShield = new G4LogicalVolume(upperLarShield,mat_ArLiq,"log_upperLarShield");
    logical_upperLarShield->SetVisAttributes ( new G4VisAttributes(G4Colour(0.1,0.9,0.1)) ); //green
    physical_upperLarShield = new G4PVPlacement(0,G4ThreeVector(0,0,0),logical_upperLarShield,"phy_upperLarShield",logical_upperSSCryostat,false,0,checkOverlaps);


    //4 modules; each needs a unique logical volume, I guess... Otherwise name overlap issues occur


    innerCopperCryostat = new G4Tubs("sol_innerCu",0*m, 0.5*m, 1*m, 0, 2*M_PI);
    innerLarShield = new G4Tubs("sol_innerLarShield",0*m, 0.49*m, 0.99*m, 0, 2*M_PI);


logical_innerCopperCryostat1 = new G4LogicalVolume(innerCopperCryostat,mat_Cu,"log_innerCopperCryostat1");
 logical_innerCopperCryostat1->SetVisAttributes ( new G4VisAttributes(G4Colour(0.62, 0.3, 0.2,0.7) ));//Brown
physical_innerCopperCryostat = new G4PVPlacement(0,G4ThreeVector(1*m,0,0),logical_innerCopperCryostat1,"phy_innerCopperCryostat1",logical_outerLarShield,false,0,checkOverlaps);

logical_innerCopperCryostat2 = new G4LogicalVolume(innerCopperCryostat,mat_Cu,"log_innerCopperCryostat2");
 logical_innerCopperCryostat2->SetVisAttributes ( new G4VisAttributes(G4Colour(0.62, 0.3, 0.2,0.7) ));//Brown
physical_innerCopperCryostat = new G4PVPlacement(0,G4ThreeVector(-1*m,0,0),logical_innerCopperCryostat2,"phy_innerCopperCryostat2",logical_outerLarShield,false,0,checkOverlaps);

logical_innerCopperCryostat3 = new G4LogicalVolume(innerCopperCryostat,mat_Cu,"log_innerCopperCryostat3");
 logical_innerCopperCryostat3->SetVisAttributes ( new G4VisAttributes(G4Colour(0.62, 0.3, 0.2,0.7) ));//Brown
physical_innerCopperCryostat = new G4PVPlacement(0,G4ThreeVector(0,1*m,0),logical_innerCopperCryostat3,"phy_innerCopperCryostat3",logical_outerLarShield,false,0,checkOverlaps);

logical_innerCopperCryostat4 = new G4LogicalVolume(innerCopperCryostat,mat_Cu,"log_innerCopperCryostat4");
 logical_innerCopperCryostat4->SetVisAttributes ( new G4VisAttributes(G4Colour(0.62, 0.3, 0.2,0.7) ));//Brown
physical_innerCopperCryostat = new G4PVPlacement(0,G4ThreeVector(0,-1*m,0),logical_innerCopperCryostat4,"phy_innerCopperCryostat4",logical_outerLarShield,false,0,checkOverlaps);


    logical_innerLarShield1 = new G4LogicalVolume(innerLarShield,mat_ArLiq,"log_innerLarShield1");
    logical_innerLarShield1->SetVisAttributes ( new G4VisAttributes(G4Colour(0.1,0.9,0.1)) ); //green
    physical_innerLarShield = new G4PVPlacement(0,G4ThreeVector(0,0,0),logical_innerLarShield1,"phy_innerLarShield1",logical_innerCopperCryostat1,false,0,checkOverlaps);    

    logical_innerLarShield2 = new G4LogicalVolume(innerLarShield,mat_ArLiq,"log_innerLarShield2");
    logical_innerLarShield2->SetVisAttributes ( new G4VisAttributes(G4Colour(0.1,0.9,0.1)) ); //green
    physical_innerLarShield = new G4PVPlacement(0,G4ThreeVector(0,0,0),logical_innerLarShield2,"phy_innerLarShield2",logical_innerCopperCryostat2,false,0,checkOverlaps);    

    logical_innerLarShield3 = new G4LogicalVolume(innerLarShield,mat_ArLiq,"log_innerLarShield3");
    logical_innerLarShield3->SetVisAttributes ( new G4VisAttributes(G4Colour(0.1,0.9,0.1)) ); //green
    physical_innerLarShield = new G4PVPlacement(0,G4ThreeVector(0,0,0),logical_innerLarShield3,"phy_innerLarShield3",logical_innerCopperCryostat3,false,0,checkOverlaps);    

    logical_innerLarShield4 = new G4LogicalVolume(innerLarShield,mat_ArLiq,"log_innerLarShield4");
    logical_innerLarShield4->SetVisAttributes ( new G4VisAttributes(G4Colour(0.1,0.9,0.1)) ); //green
    physical_innerLarShield = new G4PVPlacement(0,G4ThreeVector(0,0,0),logical_innerLarShield4,"phy_innerLarShield4",logical_innerCopperCryostat4,false,0,checkOverlaps);    



    //detector array
    ICPCshell = new G4Tubs("sol_ICPCshell",0*m, 4.5*cm, 3.75*cm, 0, 2*M_PI);
borehole = new G4Tubs("sol_borehole",0*m, 0.5*cm, 2.5*cm, 0, 2*M_PI);
ICPCdetector = new G4SubtractionSolid("sol_ICPC", ICPCshell, borehole,0, G4ThreeVector(0,0,1.25*cm));//carve out borehole from ICPC
logical_ICPCdetector  = new G4LogicalVolume(ICPCdetector,mat_Detector,"log_ICPC");
 logical_ICPCdetector->SetVisAttributes ( new G4VisAttributes(G4Colour(0.6,0.1,0.6)) );//Purple


 //physical_ICPCdetector  = new G4PVPlacement(0,G4ThreeVector(0,0,0),logical_ICPCdetector,"phy_ICPC",logical_innerLarShield1,false,0,checkOverlaps);    

 //There HAS to be a better way to implement the detector array than what I'm about to do. Gods of programming, please forgive me for this egregious crime against the holy principles of encapsulation and softcoding...

  const int numberofdetectors = 102;
  const int numberofstrings = 17;
  const int inscribingradius = 400;//mm
  const int verticalspacing = 250;//mm

  double azimuth = 0;
  int zcounter = 0;
  int longeststring = 0;

  double x = 0;
  double y = 0;
  double z = 0;

    longeststring = numberofdetectors/numberofstrings;
    if(numberofdetectors%numberofstrings)
      longeststring++;
    G4cout << longeststring << G4endl << G4endl;
  
    z = verticalspacing*(longeststring-1)/2;

  for (int i = 0; i < numberofdetectors; i++)
    {

      if(!(i%numberofstrings)&&(i))
	z = z-verticalspacing;

      azimuth = (2*TMath::Pi()*(i%numberofstrings))/numberofstrings;
    
      x = TMath::Cos(azimuth)*inscribingradius;
      y = TMath::Sin(azimuth)*inscribingradius;

      G4cout << i << G4endl << "x: " << x << G4endl<< "y: " << y << G4endl << "z: " << z << G4endl << G4endl;

    detector_name = "phy_DetGeCrystal_";
    detector_name += G4UIcommand::ConvertToString(i*4);
physical_ICPCdetector  = new G4PVPlacement(0,G4ThreeVector(x,y,z),logical_ICPCdetector,detector_name,logical_innerLarShield1,false,0,checkOverlaps);    

    detector_name = "phy_DetGeCrystal_";
    detector_name += G4UIcommand::ConvertToString(i*4+1);
physical_ICPCdetector  = new G4PVPlacement(0,G4ThreeVector(x,y,z),logical_ICPCdetector,detector_name,logical_innerLarShield2,false,0,checkOverlaps);    

    detector_name = "phy_DetGeCrystal_";
    detector_name += G4UIcommand::ConvertToString(i*4+2);
physical_ICPCdetector  = new G4PVPlacement(0,G4ThreeVector(x,y,z),logical_ICPCdetector,detector_name,logical_innerLarShield3,false,0,checkOverlaps);    

    detector_name = "phy_DetGeCrystal_";
    detector_name += G4UIcommand::ConvertToString(i*4+3);
physical_ICPCdetector  = new G4PVPlacement(0,G4ThreeVector(x,y,z),logical_ICPCdetector,detector_name,logical_innerLarShield4,false,0,checkOverlaps);    

    }



    return physical_World;
   }



 else//NoRock, or a garbage value, results in rock not being included
   {
     G4cout << G4endl << "NoRock (or invalid value): simulating with default detector assembly..." << G4endl << G4endl;
   }
